<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a>jsfeat (v0.0.8)</a>
</h1>
<h4>JavaScript Computer Vision library</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat">module jsfeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.data_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>data_t
            <span class="apidocSignatureSpan">(size_in_bytes, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.get_channel">
            function <span class="apidocSignatureSpan">jsfeat.</span>get_channel
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.get_data_type">
            function <span class="apidocSignatureSpan">jsfeat.</span>get_data_type
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.get_data_type_size">
            function <span class="apidocSignatureSpan">jsfeat.</span>get_data_type_size
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.keypoint_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>keypoint_t
            <span class="apidocSignatureSpan">(x, y, score, level, angle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matrix_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>matrix_t
            <span class="apidocSignatureSpan">(c, r, data_type, data_buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d">
            function <span class="apidocSignatureSpan">jsfeat.</span>motion_model.affine2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d">
            function <span class="apidocSignatureSpan">jsfeat.</span>motion_model.homography2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.pyramid_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>pyramid_t
            <span class="apidocSignatureSpan">(levels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.ransac_params_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>ransac_params_t
            <span class="apidocSignatureSpan">(size, thresh, eps, prob)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>BOX_BLUR_NOSCALE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>C1_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>C2_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>C3_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>C4_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>COLOR_BGR2GRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>COLOR_BGRA2GRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>COLOR_RGB2GRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>COLOR_RGBA2GRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>EPSILON</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>F32C1_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>F32C2_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>F32_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>F64_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>FLT_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>S32C1_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>S32C2_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>S32_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>S64_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>SVD_U_T</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>SVD_V_T</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>U8C1_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>U8C3_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>U8C4_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.</span>U8_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>bbf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>fast_corners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>haar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>imgproc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>linalg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>math</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>matmath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>matrix_t.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>motion_estimator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>motion_model</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>motion_model.affine2d.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>motion_model.homography2d.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>optical_flow_lk</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>orb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>pyramid_t.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>ransac_params_t.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>yape</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.</span>yape06</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jsfeat.</span>REVISION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.bbf">module jsfeat.bbf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.bbf.build_pyramid">
            function <span class="apidocSignatureSpan">jsfeat.bbf.</span>build_pyramid
            <span class="apidocSignatureSpan">(src, min_width, min_height, interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.bbf.detect">
            function <span class="apidocSignatureSpan">jsfeat.bbf.</span>detect
            <span class="apidocSignatureSpan">(pyramid, cascade)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.bbf.group_rectangles">
            function <span class="apidocSignatureSpan">jsfeat.bbf.</span>group_rectangles
            <span class="apidocSignatureSpan">(rects, min_neighbors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.bbf.prepare_cascade">
            function <span class="apidocSignatureSpan">jsfeat.bbf.</span>prepare_cascade
            <span class="apidocSignatureSpan">(cascade)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.bbf.</span>interval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.bbf.</span>next</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.bbf.</span>scale</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.bbf.</span>scale_to</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.cache">module jsfeat.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.cache.allocate">
            function <span class="apidocSignatureSpan">jsfeat.cache.</span>allocate
            <span class="apidocSignatureSpan">(capacity, data_size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.cache.get_buffer">
            function <span class="apidocSignatureSpan">jsfeat.cache.</span>get_buffer
            <span class="apidocSignatureSpan">(size_in_bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.cache.put_buffer">
            function <span class="apidocSignatureSpan">jsfeat.cache.</span>put_buffer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.fast_corners">module jsfeat.fast_corners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.fast_corners.detect">
            function <span class="apidocSignatureSpan">jsfeat.fast_corners.</span>detect
            <span class="apidocSignatureSpan">(src, corners, border)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.fast_corners.set_threshold">
            function <span class="apidocSignatureSpan">jsfeat.fast_corners.</span>set_threshold
            <span class="apidocSignatureSpan">(threshold)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.haar">module jsfeat.haar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.haar.detect_multi_scale">
            function <span class="apidocSignatureSpan">jsfeat.haar.</span>detect_multi_scale
            <span class="apidocSignatureSpan">(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, classifier, scale_factor, scale_min)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.haar.detect_single_scale">
            function <span class="apidocSignatureSpan">jsfeat.haar.</span>detect_single_scale
            <span class="apidocSignatureSpan">(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, scale, classifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.haar.group_rectangles">
            function <span class="apidocSignatureSpan">jsfeat.haar.</span>group_rectangles
            <span class="apidocSignatureSpan">(rects, min_neighbors)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.haar.</span>edges_density</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.imgproc">module jsfeat.imgproc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.box_blur_gray">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>box_blur_gray
            <span class="apidocSignatureSpan">(src, dst, radius, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.canny">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>canny
            <span class="apidocSignatureSpan">(src, dst, low_thresh, high_thresh)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.compute_integral_image">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>compute_integral_image
            <span class="apidocSignatureSpan">(src, dst_sum, dst_sqsum, dst_tilted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.equalize_histogram">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>equalize_histogram
            <span class="apidocSignatureSpan">(src, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.gaussian_blur">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>gaussian_blur
            <span class="apidocSignatureSpan">(src, dst, kernel_size, sigma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.grayscale">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>grayscale
            <span class="apidocSignatureSpan">(src, w, h, dst, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.pyrdown">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>pyrdown
            <span class="apidocSignatureSpan">(src, dst, sx, sy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.resample">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>resample
            <span class="apidocSignatureSpan">(src, dst, nw, nh)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.scharr_derivatives">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>scharr_derivatives
            <span class="apidocSignatureSpan">(src, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.skindetector">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>skindetector
            <span class="apidocSignatureSpan">(src, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.sobel_derivatives">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>sobel_derivatives
            <span class="apidocSignatureSpan">(src, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.warp_affine">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>warp_affine
            <span class="apidocSignatureSpan">(src, dst, transform, fill_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.imgproc.warp_perspective">
            function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>warp_perspective
            <span class="apidocSignatureSpan">(src, dst, transform, fill_value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.linalg">module jsfeat.linalg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.cholesky_solve">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>cholesky_solve
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.eigenVV">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>eigenVV
            <span class="apidocSignatureSpan">(A, vects, vals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.lu_solve">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>lu_solve
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.svd_decompose">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_decompose
            <span class="apidocSignatureSpan">(A, W, U, V, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.svd_invert">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_invert
            <span class="apidocSignatureSpan">(Ai, A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.linalg.svd_solve">
            function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_solve
            <span class="apidocSignatureSpan">(A, X, B)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.math">module jsfeat.math</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.math.get_gaussian_kernel">
            function <span class="apidocSignatureSpan">jsfeat.math.</span>get_gaussian_kernel
            <span class="apidocSignatureSpan">(size, sigma, kernel, data_type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.math.median">
            function <span class="apidocSignatureSpan">jsfeat.math.</span>median
            <span class="apidocSignatureSpan">(array, low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.math.perspective_4point_transform">
            function <span class="apidocSignatureSpan">jsfeat.math.</span>perspective_4point_transform
            <span class="apidocSignatureSpan">(model, src_x0, src_y0, dst_x0, dst_y0, src_x1, src_y1, dst_x1, dst_y1, src_x2, src_y2, dst_x2, dst_y2, src_x3, src_y3, dst_x3, dst_y3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.math.qsort">
            function <span class="apidocSignatureSpan">jsfeat.math.</span>qsort
            <span class="apidocSignatureSpan">(array, low, high, cmp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.matmath">module jsfeat.matmath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.determinant_3x3">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>determinant_3x3
            <span class="apidocSignatureSpan">(M11, M12, M13, M21, M22, M23, M31, M32, M33)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.identity">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>identity
            <span class="apidocSignatureSpan">(M, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.identity_3x3">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>identity_3x3
            <span class="apidocSignatureSpan">(M, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.invert_3x3">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>invert_3x3
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.mat3x3_determinant">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>mat3x3_determinant
            <span class="apidocSignatureSpan">(M)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply
            <span class="apidocSignatureSpan">(C, A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply_3x3">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_3x3
            <span class="apidocSignatureSpan">(C, A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply_AAt">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AAt
            <span class="apidocSignatureSpan">(C, A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply_ABt">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_ABt
            <span class="apidocSignatureSpan">(C, A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply_AtA">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AtA
            <span class="apidocSignatureSpan">(C, A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.multiply_AtB">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AtB
            <span class="apidocSignatureSpan">(C, A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matmath.transpose">
            function <span class="apidocSignatureSpan">jsfeat.matmath.</span>transpose
            <span class="apidocSignatureSpan">(At, A)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.matrix_t">module jsfeat.matrix_t</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matrix_t.matrix_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>matrix_t
            <span class="apidocSignatureSpan">(c, r, data_type, data_buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.matrix_t.prototype">module jsfeat.matrix_t.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matrix_t.prototype.allocate">
            function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>allocate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matrix_t.prototype.copy_to">
            function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>copy_to
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.matrix_t.prototype.resize">
            function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>resize
            <span class="apidocSignatureSpan">(c, r, ch)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_estimator">module jsfeat.motion_estimator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_estimator.lmeds">
            function <span class="apidocSignatureSpan">jsfeat.motion_estimator.</span>lmeds
            <span class="apidocSignatureSpan">(params, kernel, from, to, count, model, mask, max_iters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_estimator.ransac">
            function <span class="apidocSignatureSpan">jsfeat.motion_estimator.</span>ransac
            <span class="apidocSignatureSpan">(params, kernel, from, to, count, model, mask, max_iters)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_model">module jsfeat.motion_model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>affine2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>homography2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_model.affine2d">module jsfeat.motion_model.affine2d</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d.affine2d">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>affine2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_model.affine2d.prototype">module jsfeat.motion_model.affine2d.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.check_subset">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>check_subset
            <span class="apidocSignatureSpan">(from, to, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.error">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>error
            <span class="apidocSignatureSpan">(from, to, model, err, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.run">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>run
            <span class="apidocSignatureSpan">(from, to, model, count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_model.homography2d">module jsfeat.motion_model.homography2d</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d.homography2d">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>homography2d
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.motion_model.homography2d.prototype">module jsfeat.motion_model.homography2d.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.check_subset">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>check_subset
            <span class="apidocSignatureSpan">(from, to, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.error">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>error
            <span class="apidocSignatureSpan">(from, to, model, err, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.run">
            function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>run
            <span class="apidocSignatureSpan">(from, to, model, count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.optical_flow_lk">module jsfeat.optical_flow_lk</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.optical_flow_lk.track">
            function <span class="apidocSignatureSpan">jsfeat.optical_flow_lk.</span>track
            <span class="apidocSignatureSpan">(prev_pyr, curr_pyr, prev_xy, curr_xy, count, win_size, max_iter, status, eps, min_eigen_threshold)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.orb">module jsfeat.orb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.orb.describe">
            function <span class="apidocSignatureSpan">jsfeat.orb.</span>describe
            <span class="apidocSignatureSpan">(src, corners, count, descriptors)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.pyramid_t">module jsfeat.pyramid_t</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.pyramid_t.pyramid_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>pyramid_t
            <span class="apidocSignatureSpan">(levels)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.pyramid_t.prototype">module jsfeat.pyramid_t.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.pyramid_t.prototype.allocate">
            function <span class="apidocSignatureSpan">jsfeat.pyramid_t.prototype.</span>allocate
            <span class="apidocSignatureSpan">(start_w, start_h, data_type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.pyramid_t.prototype.build">
            function <span class="apidocSignatureSpan">jsfeat.pyramid_t.prototype.</span>build
            <span class="apidocSignatureSpan">(input, skip_first_level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.ransac_params_t">module jsfeat.ransac_params_t</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.ransac_params_t.ransac_params_t">
            function <span class="apidocSignatureSpan">jsfeat.</span>ransac_params_t
            <span class="apidocSignatureSpan">(size, thresh, eps, prob)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.ransac_params_t.prototype">module jsfeat.ransac_params_t.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.ransac_params_t.prototype.update_iters">
            function <span class="apidocSignatureSpan">jsfeat.ransac_params_t.prototype.</span>update_iters
            <span class="apidocSignatureSpan">(_eps, max_iters)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.yape">module jsfeat.yape</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.yape.detect">
            function <span class="apidocSignatureSpan">jsfeat.yape.</span>detect
            <span class="apidocSignatureSpan">(src, points, border)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.yape.init">
            function <span class="apidocSignatureSpan">jsfeat.yape.</span>init
            <span class="apidocSignatureSpan">(width, height, radius, pyramid_levels)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.yape.</span>tau</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsfeat.yape.</span>level_tables</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsfeat.yape06">module jsfeat.yape06</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsfeat.yape06.detect">
            function <span class="apidocSignatureSpan">jsfeat.yape06.</span>detect
            <span class="apidocSignatureSpan">(src, points, border)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.yape06.</span>laplacian_threshold</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsfeat.yape06.</span>min_eigen_value_threshold</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat" id="apidoc.module.jsfeat">module jsfeat</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.data_t" id="apidoc.element.jsfeat.data_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>data_t
        <span class="apidocSignatureSpan">(size_in_bytes, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function data_t(size_in_bytes, buffer) {
    // we need align size to multiple of 8
    this.size = ((size_in_bytes + 7) | 0) &amp; -8;
    if (typeof buffer === "undefined") {
        this.buffer = new ArrayBuffer(this.size);
    } else {
        this.buffer = buffer;
        this.size = buffer.length;
    }
    this.u8 = new Uint8Array(this.buffer);
    this.i32 = new Int32Array(this.buffer);
    this.f32 = new Float32Array(this.buffer);
    this.f64 = new Float64Array(this.buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// very primitive array cache, still need testing if it helps
// of course V8 has its own powerful cache sys but i'm not sure
// it caches several multichannel 640x480 buffer creations each frame

var _pool_node_t = (function () {
    function _pool_node_t(size_in_bytes) {
        this.next = null;
        this.data = new jsfeat.<span class="apidocCodeKeywordSpan">data_t</span>(size_in_bytes);
        this.size = this.data.size;
        this.buffer = this.data.buffer;
        this.u8 = this.data.u8;
        this.i32 = this.data.i32;
        this.f32 = this.data.f32;
        this.f64 = this.data.f64;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.get_channel" id="apidoc.element.jsfeat.get_channel">
        function <span class="apidocSignatureSpan">jsfeat.</span>get_channel
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_channel = function (type) {
    return (type &amp; 0xFF);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.get_data_type" id="apidoc.element.jsfeat.get_data_type">
        function <span class="apidocSignatureSpan">jsfeat.</span>get_data_type
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_data_type = function (type) {
    return (type &amp; 0xFF00);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.get_data_type_size" id="apidoc.element.jsfeat.get_data_type_size">
        function <span class="apidocSignatureSpan">jsfeat.</span>get_data_type_size
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_data_type_size = function (type) {
    return _data_type_size[(type &amp; 0xFF00) &gt;&gt; 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.keypoint_t" id="apidoc.element.jsfeat.keypoint_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>keypoint_t
        <span class="apidocSignatureSpan">(x, y, score, level, angle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function keypoint_t(x, y, score, level, angle) {
    if (typeof x === "undefined") { x=0; }
    if (typeof y === "undefined") { y=0; }
    if (typeof score === "undefined") { score=0; }
    if (typeof level === "undefined") { level=0; }
    if (typeof angle === "undefined") { angle=-1.0; }

    this.x = x;
    this.y = y;
    this.score = score;
    this.level = level;
    this.angle = angle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matrix_t" id="apidoc.element.jsfeat.matrix_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>matrix_t
        <span class="apidocSignatureSpan">(c, r, data_type, data_buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matrix_t(c, r, data_type, data_buffer) {
    this.type = get_data_type(data_type)|0;
    this.channel = get_channel(data_type)|0;
    this.cols = c|0;
    this.rows = r|0;
    if (typeof data_buffer === "undefined") {
        this.allocate();
    } else {
        this.buffer = data_buffer;
        // data user asked for
        this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this.buffer.f32 :
this.buffer.f64));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    n = i;
}

var a_buff = jsfeat.cache.get_buffer((m*m)&lt;&lt;3);
var w_buff = jsfeat.cache.get_buffer(n&lt;&lt;3);
var v_buff = jsfeat.cache.get_buffer((n*n)&lt;&lt;3);

var a_mt = new jsfeat.<span class="apidocCodeKeywordSpan">matrix_t</span>(m, m, dt, a_buff.data);
var w_mt = new jsfeat.matrix_t(1, n, dt, w_buff.data);
var v_mt = new jsfeat.matrix_t(n, n, dt, v_buff.data);

if(at == 0) {
    // transpose
    jsfeat.matmath.transpose(a_mt, A);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d" id="apidoc.element.jsfeat.motion_model.affine2d">
        function <span class="apidocSignatureSpan">jsfeat.</span>motion_model.affine2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function affine2d() {
	        	// empty constructor
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d" id="apidoc.element.jsfeat.motion_model.homography2d">
        function <span class="apidocSignatureSpan">jsfeat.</span>motion_model.homography2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function homography2d() {
	        	// empty constructor
	        	//this.T0 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.T1 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.mLtL = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.Evec = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.pyramid_t" id="apidoc.element.jsfeat.pyramid_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>pyramid_t
        <span class="apidocSignatureSpan">(levels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pyramid_t(levels) {
    this.levels = levels|0;
    this.data = new Array(levels);
    this.pyrdown = jsfeat.imgproc.pyrdown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       r2.x &gt;= r1.x - distance &amp;&amp;
       r2.y &lt;= r1.y + distance &amp;&amp;
       r2.y &gt;= r1.y - distance &amp;&amp;
       r2.width &lt;= (r1.width * 1.5 + 0.5)|0 &amp;&amp;
       (r2.width * 1.5 + 0.5)|0 &gt;= r1.width;
        }

        var img_pyr = new jsfeat.<span class="apidocCodeKeywordSpan">pyramid_t</span>(1);

        return {

interval: 4,
scale: 1.1486,
next: 5,
scale_to: 1,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.ransac_params_t" id="apidoc.element.jsfeat.ransac_params_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>ransac_params_t
        <span class="apidocSignatureSpan">(size, thresh, eps, prob)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ransac_params_t(size, thresh, eps, prob) {
    if (typeof size === "undefined") { size=0; }
    if (typeof thresh === "undefined") { thresh=0.5; }
    if (typeof eps === "undefined") { eps=0.5; }
    if (typeof prob === "undefined") { prob=0.99; }

    this.size = size;
    this.thresh = thresh;
    this.eps = eps;
    this.prob = prob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.bbf" id="apidoc.module.jsfeat.bbf">module jsfeat.bbf</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.bbf.build_pyramid" id="apidoc.element.jsfeat.bbf.build_pyramid">
        function <span class="apidocSignatureSpan">jsfeat.bbf.</span>build_pyramid
        <span class="apidocSignatureSpan">(src, min_width, min_height, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build_pyramid = function (src, min_width, min_height, interval) {
    if (typeof interval === "undefined") { interval = 4; }

    var sw=src.cols,sh=src.rows;
    var i=0,nw=0,nh=0;
    var new_pyr=false;
    var src0=src,src1=src;
    var data_type = jsfeat.U8_t | jsfeat.C1_t;

    this.interval = interval;
    this.scale = Math.pow(2, 1 / (this.interval + 1));
    this.next = (this.interval + 1)|0;
    this.scale_to = (Math.log(Math.min(sw / min_width, sh / min_height)) / Math.log(this.scale))|0;

    var pyr_l = ((this.scale_to + this.next * 2) * 4) | 0;
    if(img_pyr.levels != pyr_l) {
        img_pyr.levels = pyr_l;
        img_pyr.data = new Array(pyr_l);
        new_pyr = true;
        img_pyr.data[0] = src; // first is src
    }

    for (i = 1; i &lt;= this.interval; ++i) {
        nw = (sw / Math.pow(this.scale, i))|0;
        nh = (sh / Math.pow(this.scale, i))|0;
        src0 = img_pyr.data[i&lt;&lt;2];
        if(new_pyr || nw != src0.cols || nh != src0.rows) {
            img_pyr.data[i&lt;&lt;2] = new jsfeat.matrix_t(nw, nh, data_type);
            src0 = img_pyr.data[i&lt;&lt;2];
        }
        jsfeat.imgproc.resample(src, src0, nw, nh);
    }
    for (i = this.next; i &lt; this.scale_to + this.next * 2; ++i) {
        src1 = img_pyr.data[(i &lt;&lt; 2) - (this.next &lt;&lt; 2)];
        src0 = img_pyr.data[i&lt;&lt;2];
        nw = src1.cols &gt;&gt; 1;
        nh = src1.rows &gt;&gt; 1;
        if(new_pyr || nw != src0.cols || nh != src0.rows) {
            img_pyr.data[i&lt;&lt;2] = new jsfeat.matrix_t(nw, nh, data_type);
            src0 = img_pyr.data[i&lt;&lt;2];
        }
        jsfeat.imgproc.pyrdown(src1, src0);
    }
    for (i = this.next * 2; i &lt; this.scale_to + this.next * 2; ++i) {
        src1 = img_pyr.data[(i &lt;&lt; 2) - (this.next &lt;&lt; 2)];
        nw = src1.cols &gt;&gt; 1;
        nh = src1.rows &gt;&gt; 1;
        src0 = img_pyr.data[(i&lt;&lt;2)+1];
        if(new_pyr || nw != src0.cols || nh != src0.rows) {
            img_pyr.data[(i&lt;&lt;2)+1] = new jsfeat.matrix_t(nw, nh, data_type);
            src0 = img_pyr.data[(i&lt;&lt;2)+1];
        }
        jsfeat.imgproc.pyrdown(src1, src0, 1, 0);
        //
        src0 = img_pyr.data[(i&lt;&lt;2)+2];
        if(new_pyr || nw != src0.cols || nh != src0.rows) {
            img_pyr.data[(i&lt;&lt;2)+2] = new jsfeat.matrix_t(nw, nh, data_type);
            src0 = img_pyr.data[(i&lt;&lt;2)+2];
        }
        jsfeat.imgproc.pyrdown(src1, src0, 0, 1);
        //
        src0 = img_pyr.data[(i&lt;&lt;2)+3];
        if(new_pyr || nw != src0.cols || nh != src0.rows) {
            img_pyr.data[(i&lt;&lt;2)+3] = new jsfeat.matrix_t(nw, nh, data_type);
            src0 = img_pyr.data[(i&lt;&lt;2)+3];
        }
        jsfeat.imgproc.pyrdown(src1, src0, 1, 1);
    }
    return img_pyr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.bbf.detect" id="apidoc.element.jsfeat.bbf.detect">
        function <span class="apidocSignatureSpan">jsfeat.bbf.</span>detect
        <span class="apidocSignatureSpan">(pyramid, cascade)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (pyramid, cascade) {
    var interval = this.interval;
    var scale = this.scale;
    var next = this.next;
    var scale_upto = this.scale_to;
    var i=0,j=0,k=0,n=0,x=0,y=0,q=0,sn=0,f_cnt=0,q_cnt=0,p=0,pmin=0,nmax=0,f=0,i4=0,qw=0,qh=0;
    var sum=0.0, alpha, feature, orig_feature, feature_k, feature_o, flag = true, shortcut=true;
    var scale_x = 1.0, scale_y = 1.0;
    var dx = [0, 1, 0, 1];
    var dy = [0, 0, 1, 1];
    var seq = [];
    var pyr=pyramid.data, bpp = 1, bpp2 = 2, bpp4 = 4;

    var u8 = [], u8o = [0,0,0];
    var step = [0,0,0];
    var paddings = [0,0,0];

    for (i = 0; i &lt; scale_upto; i++) {
        i4 = (i&lt;&lt;2);
        qw = pyr[i4 + (next &lt;&lt; 3)].cols - (cascade.width &gt;&gt; 2);
        qh = pyr[i4 + (next &lt;&lt; 3)].rows - (cascade.height &gt;&gt; 2);
        step[0] = pyr[i4].cols * bpp;
        step[1] = pyr[i4 + (next &lt;&lt; 2)].cols * bpp;
        step[2] = pyr[i4 + (next &lt;&lt; 3)].cols * bpp;
        paddings[0] = (pyr[i4].cols * bpp4) - (qw * bpp4);
        paddings[1] = (pyr[i4 + (next &lt;&lt; 2)].cols * bpp2) - (qw * bpp2);
        paddings[2] = (pyr[i4 + (next &lt;&lt; 3)].cols * bpp) - (qw * bpp);
        sn = cascade.stage_classifier.length;
        for (j = 0; j &lt; sn; j++) {
            orig_feature = cascade.stage_classifier[j].feature;
            feature = cascade.stage_classifier[j]._feature;
            f_cnt = cascade.stage_classifier[j].count;
            for (k = 0; k &lt; f_cnt; k++) {
                feature_k = feature[k];
                feature_o = orig_feature[k];
                q_cnt = feature_o.size|0;
                for (q = 0; q &lt; q_cnt; q++) {
                    feature_k.px[q] = (feature_o.px[q] * bpp) + feature_o.py[q] * step[feature_o.pz[q]];
                    feature_k.pz[q] = feature_o.pz[q];
                    feature_k.nx[q] = (feature_o.nx[q] * bpp) + feature_o.ny[q] * step[feature_o.nz[q]];
                    feature_k.nz[q] = feature_o.nz[q];
                }
            }
        }
        u8[0] = pyr[i4].data; u8[1] = pyr[i4 + (next&lt;&lt;2)].data;
        for (q = 0; q &lt; 4; q++) {
            u8[2] = pyr[i4 + (next&lt;&lt;3) + q].data;
            u8o[0] = (dx[q]*bpp2) + dy[q] * (pyr[i4].cols*bpp2);
            u8o[1] = (dx[q]*bpp) + dy[q] * (pyr[i4 + (next&lt;&lt;2)].cols*bpp);
            u8o[2] = 0;
            for (y = 0; y &lt; qh; y++) {
                for (x = 0; x &lt; qw; x++) {
                    sum = 0;
                    flag = true;
                    sn = cascade.stage_classifier.length;
                    for (j = 0; j &lt; sn; j++) {
                        sum = 0;
                        alpha = cascade.stage_classifier[j].alpha;
                        feature = cascade.stage_classifier[j]._feature;
                        f_cnt = cascade.stage_classifier[j].count;
                        for (k = 0; k &lt; f_cnt; k++) {
                            feature_k = feature[k];
                            pmin = u8[feature_k.pz[0]][u8o[feature_k.pz[0]] + feature_k.px[0]];
                            nmax = u8[feature_k.nz[0]][u8o[feature_k.nz[0]] + feature_k.nx[0]];
                            if (pmin &lt;= nmax) {
                                sum += alpha[k &lt;&lt; 1];
                            } else {
                                shortcut = true;
                                q_cnt = feature_k.size;
                                for (f = 1; f &lt; q_cnt; f++) {
                                    if (feature_k.pz[f] &gt;= 0) {
                                        p = u8[feature_k.pz[f]][u8o[feature_k.pz[f]] + feature_k.px[f]];
                                        if (p &lt; pmin) {
                                            if (p &lt;= nmax) {
                                                shortcut = false;
                                                break;
                                            }
                                            pmin = p;
                                        }
                                    }
                                    if (feature_k.nz[f] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.bbf.group_rectangles" id="apidoc.element.jsfeat.bbf.group_rectangles">
        function <span class="apidocSignatureSpan">jsfeat.bbf.</span>group_rectangles
        <span class="apidocSignatureSpan">(rects, min_neighbors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group_rectangles = function (rects, min_neighbors) {
    if (typeof min_neighbors === "undefined") { min_neighbors = 1; }
    var i, j, n = rects.length;
    var node = [];
    for (i = 0; i &lt; n; ++i) {
        node[i] = {"parent" : -1,
                   "element" : rects[i],
                   "rank" : 0};
    }
    for (i = 0; i &lt; n; ++i) {
        if (!node[i].element)
            continue;
        var root = i;
        while (node[root].parent != -1)
            root = node[root].parent;
        for (j = 0; j &lt; n; ++j) {
            if( i != j &amp;&amp; node[j].element &amp;&amp; _group_func(node[i].element, node[j].element)) {
                var root2 = j;

                while (node[root2].parent != -1)
                    root2 = node[root2].parent;

                if(root2 != root) {
                    if(node[root].rank &gt; node[root2].rank)
                        node[root2].parent = root;
                    else {
                        node[root].parent = root2;
                        if (node[root].rank == node[root2].rank)
                        node[root2].rank++;
                        root = root2;
                    }

                    /* compress path from node2 to the root: */
                    var temp, node2 = j;
                    while (node[node2].parent != -1) {
                        temp = node2;
                        node2 = node[node2].parent;
                        node[temp].parent = root;
                    }

                    /* compress path from node to the root: */
                    node2 = i;
                    while (node[node2].parent != -1) {
                        temp = node2;
                        node2 = node[node2].parent;
                        node[temp].parent = root;
                    }
                }
            }
        }
    }
    var idx_seq = [];
    var class_idx = 0;
    for(i = 0; i &lt; n; i++) {
        j = -1;
        var node1 = i;
        if(node[node1].element) {
            while (node[node1].parent != -1)
                node1 = node[node1].parent;
            if(node[node1].rank &gt;= 0)
                node[node1].rank = ~class_idx++;
            j = ~node[node1].rank;
        }
        idx_seq[i] = j;
    }

    var comps = [];
    for (i = 0; i &lt; class_idx+1; ++i) {
        comps[i] = {"neighbors" : 0,
                    "x" : 0,
                    "y" : 0,
                    "width" : 0,
                    "height" : 0,
                    "confidence" : 0};
    }

    // count number of neighbors
    for(i = 0; i &lt; n; ++i) {
        var r1 = rects[i];
        var idx = idx_seq[i];

        if (comps[idx].neighbors == 0)
            comps[idx].confidence = r1.confidence;

        ++comps[idx].neighbors;

        comps[idx].x += r1.x;
        comps[idx].y += r1.y;
        comps[idx].width += r1.width;
        comps[idx].height += r1.height;
        comps[idx].confidence = Math.max(comps[idx].confidence, r1.confidence);
    }

    var seq2 = [];
    // calculate average bounding box
    for(i = 0; i &lt; class_idx; ++i) {
        n = comps[i].neighbors;
        if (n &gt;= min_neighbors)
            seq2.push({"x" : (comps[i].x * 2 + n) / (2 * n),
                       "y" : (comps[i].y * 2 + n) / (2 * n),
                       "width" : (comps[i].width * 2 + n) / (2 * n),
                       "height" : (comps[i].height * 2 + n) / (2 * n),
                       "neighbors" : comps[i].neighbors,
                       "confidence" : comps[i].confidence});
    }

    var result_seq = [];
    n = seq2.length;
    // filter out small face rectangles inside large face rectangles
    for(i = 0; i &lt; n; ++i) {
        var r1 = seq2[i];
        var flag = true;
        for(j = 0; j &lt; n; ++j) {
            var r2 = seq2[j];
            var distance = (r2.width * 0.25 + 0.5)|0;

            if(i != j &amp;&amp;
               r1.x &gt;= r2.x - distance &amp;&amp;
               r1.y &gt;= r2.y - distance &amp;&amp;
               r1.x + r1.width &lt;= r2.x + r2.width + dista ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.bbf.prepare_cascade" id="apidoc.element.jsfeat.bbf.prepare_cascade">
        function <span class="apidocSignatureSpan">jsfeat.bbf.</span>prepare_cascade
        <span class="apidocSignatureSpan">(cascade)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepare_cascade = function (cascade) {
    var sn = cascade.stage_classifier.length;
    for (var j = 0; j &lt; sn; j++) {
        var orig_feature = cascade.stage_classifier[j].feature;
        var f_cnt = cascade.stage_classifier[j].count;
        var feature = cascade.stage_classifier[j]._feature = new Array(f_cnt);
        for (var k = 0; k &lt; f_cnt; k++) {
            feature[k] = {"size" : orig_feature[k].size,
                          "px" : new Array(orig_feature[k].size),
                          "pz" : new Array(orig_feature[k].size),
                          "nx" : new Array(orig_feature[k].size),
                          "nz" : new Array(orig_feature[k].size)};
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.cache" id="apidoc.module.jsfeat.cache">module jsfeat.cache</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.cache.allocate" id="apidoc.element.jsfeat.cache.allocate">
        function <span class="apidocSignatureSpan">jsfeat.cache.</span>allocate
        <span class="apidocSignatureSpan">(capacity, data_size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocate = function (capacity, data_size) {
    _pool_head = _pool_tail = new _pool_node_t(data_size);
    for (var i = 0; i &lt; capacity; ++i) {
        var node = new _pool_node_t(data_size);
        _pool_tail = _pool_tail.next = node;

        _pool_size++;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// columns, rows, data_type
function matrix_t(c, r, data_type, data_buffer) {
    this.type = get_data_type(data_type)|0;
    this.channel = get_channel(data_type)|0;
    this.cols = c|0;
    this.rows = r|0;
    if (typeof data_buffer === "undefined") {
        this.<span class="apidocCodeKeywordSpan">allocate</span>();
    } else {
        this.buffer = data_buffer;
        // data user asked for
        this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this
.buffer.f32 : this.buffer.f64));
    }
}
matrix_t.prototype.allocate = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.cache.get_buffer" id="apidoc.element.jsfeat.cache.get_buffer">
        function <span class="apidocSignatureSpan">jsfeat.cache.</span>get_buffer
        <span class="apidocSignatureSpan">(size_in_bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_buffer = function (size_in_bytes) {
    // assume we have enough free nodes
    var node = _pool_head;
    _pool_head = _pool_head.next;
    _pool_size--;

    if(size_in_bytes &gt; node.size) {
        node.resize(size_in_bytes);
    }

    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        var qsort_stack = new Int32Array(48*2);

        return {
            get_gaussian_kernel: function(size, sigma, kernel, data_type) {
var i=0,x=0.0,t=0.0,sigma_x=0.0,scale_2x=0.0;
var sum = 0.0;
var kern_node = jsfeat.cache.<span class="apidocCodeKeywordSpan">get_buffer</span>(size&lt;&lt;2);
var _kernel = kern_node.f32;//new Float32Array(size);

if((size&amp;1) == 1 &amp;&amp; size &lt;= 7 &amp;&amp; sigma &lt;= 0) {
    switch(size&gt;&gt;1) {
        case 0:
        _kernel[0] = 1.0;
        sum = 1.0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.cache.put_buffer" id="apidoc.element.jsfeat.cache.put_buffer">
        function <span class="apidocSignatureSpan">jsfeat.cache.</span>put_buffer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put_buffer = function (node) {
    _pool_tail = _pool_tail.next = node;
    _pool_size++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // classic kernel
        sum = 1.0/sum;
        for (i = 0; i &lt; size; ++i) {
            kernel[i] = _kernel[i] * sum;
        }
    }

    jsfeat.cache.<span class="apidocCodeKeywordSpan">put_buffer</span>(kern_node);
},

// model is 3x3 matrix_t
perspective_4point_transform: function(model, src_x0, src_y0, dst_x0, dst_y0,
                                            src_x1, src_y1, dst_x1, dst_y1,
                                            src_x2, src_y2, dst_x2, dst_y2,
                                            src_x3, src_y3, dst_x3, dst_y3) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.fast_corners" id="apidoc.module.jsfeat.fast_corners">module jsfeat.fast_corners</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.fast_corners.detect" id="apidoc.element.jsfeat.fast_corners.detect">
        function <span class="apidocSignatureSpan">jsfeat.fast_corners.</span>detect
        <span class="apidocSignatureSpan">(src, corners, border)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (src, corners, border) {
    if (typeof border === "undefined") { border = 3; }

    var K = 8, N = 25;
    var img = src.data, w = src.cols, h = src.rows;
    var i=0, j=0, k=0, vt=0, x=0, m3=0;
    var buf_node = jsfeat.cache.get_buffer(3 * w);
    var cpbuf_node = jsfeat.cache.get_buffer(((w+1)*3)&lt;&lt;2);
    var buf = buf_node.u8;
    var cpbuf = cpbuf_node.i32;
    var pixel = pixel_off;
    var sd = score_diff;
    var sy = Math.max(3, border);
    var ey = Math.min((h-2), (h-border));
    var sx = Math.max(3, border);
    var ex = Math.min((w - 3), (w - border));
    var _count = 0, corners_cnt = 0, pt;
    var score_func = _cmp_score_16;
    var thresh_tab = threshold_tab;
    var threshold = _threshold;

    var v=0,tab=0,d=0,ncorners=0,cornerpos=0,curr=0,ptr=0,prev=0,pprev=0;
    var jp1=0,jm1=0,score=0;

    _cmp_offsets(pixel, w, 16);

    // local vars are faster?
    var pixel0 = pixel[0];
    var pixel1 = pixel[1];
    var pixel2 = pixel[2];
    var pixel3 = pixel[3];
    var pixel4 = pixel[4];
    var pixel5 = pixel[5];
    var pixel6 = pixel[6];
    var pixel7 = pixel[7];
    var pixel8 = pixel[8];
    var pixel9 = pixel[9];
    var pixel10 = pixel[10];
    var pixel11 = pixel[11];
    var pixel12 = pixel[12];
    var pixel13 = pixel[13];
    var pixel14 = pixel[14];
    var pixel15 = pixel[15];

    for(i = 0; i &lt; w*3; ++i) {
        buf[i] = 0;
    }

    for(i = sy; i &lt; ey; ++i) {
        ptr = ((i * w) + sx)|0;
        m3 = (i - 3)%3;
        curr = (m3*w)|0;
        cornerpos = (m3*(w+1))|0;
        for (j = 0; j &lt; w; ++j) buf[curr+j] = 0;
        ncorners = 0;

        if( i &lt; (ey - 1) ) {
            j = sx;

            for( ; j &lt; ex; ++j, ++ptr ) {
                v = img[ptr];
                tab = ( - v + 255 );
                d = ( thresh_tab[tab+img[ptr+pixel0]] | thresh_tab[tab+img[ptr+pixel8]] );

                if( d == 0 ) {
                    continue;
                }

                d &amp;= ( thresh_tab[tab+img[ptr+pixel2]] | thresh_tab[tab+img[ptr+pixel10]] );
                d &amp;= ( thresh_tab[tab+img[ptr+pixel4]] | thresh_tab[tab+img[ptr+pixel12]] );
                d &amp;= ( thresh_tab[tab+img[ptr+pixel6]] | thresh_tab[tab+img[ptr+pixel14]] );

                if( d == 0 ) {
                    continue;
                }

                d &amp;= ( thresh_tab[tab+img[ptr+pixel1]] | thresh_tab[tab+img[ptr+pixel9]] );
                d &amp;= ( thresh_tab[tab+img[ptr+pixel3]] | thresh_tab[tab+img[ptr+pixel11]] );
                d &amp;= ( thresh_tab[tab+img[ptr+pixel5]] | thresh_tab[tab+img[ptr+pixel13]] );
                d &amp;= ( thresh_tab[tab+img[ptr+pixel7]] | thresh_tab[tab+img[ptr+pixel15]] );

                if( d &amp; 1 ) {
                    vt = (v - threshold);
                    _count = 0;

                    for( k = 0; k &lt; N; ++k ) {
                        x = img[(ptr+pixel[k])];
                        if(x &lt; vt) {
                            ++_count;
                            if( _count &gt; K ) {
                                ++ncorners;
                                cpbuf[cornerpos+ncorners] = j;
                                buf[curr+j] = score_func(img, ptr, pixel, sd, threshold);
                                break;
                            }
                        }
                        else {
                            _count = 0;
                        }
                    }
                }

                if( d &amp; 2 ) {
                    vt = (v + threshold);
                    _count = 0;

                    for( k = 0; k &lt; N; ++k ) {
                        x = img[(ptr+pixel[k])];
                        if(x &gt; vt) {
                            ++_count;
                            if( _count &gt; K ) {
                                ++ncorners; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.fast_corners.set_threshold" id="apidoc.element.jsfeat.fast_corners.set_threshold">
        function <span class="apidocSignatureSpan">jsfeat.fast_corners.</span>set_threshold
        <span class="apidocSignatureSpan">(threshold)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set_threshold = function (threshold) {
    _threshold = Math.min(Math.max(threshold, 0), 255);
    for (var i = -255; i &lt;= 255; ++i) {
        threshold_tab[(i + 255)] = (i &lt; -_threshold ? 1 : (i &gt; _threshold ? 2 : 0));
    }
    return _threshold;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               jsfeat.cache.put_buffer(cpbuf_node);
               return corners_cnt;
           }
       };
   })();

   global.fast_corners = fast_corners;
   fast_corners.<span class="apidocCodeKeywordSpan">set_threshold</span>(20); // set default

})(jsfeat);
/**
* @author Eugene Zatepyakin / http://inspirit.ru/
*
* Copyright 2007 Computer Vision Lab,
* Ecole Polytechnique Federale de Lausanne (EPFL), Switzerland.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.haar" id="apidoc.module.jsfeat.haar">module jsfeat.haar</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.haar.detect_multi_scale" id="apidoc.element.jsfeat.haar.detect_multi_scale">
        function <span class="apidocSignatureSpan">jsfeat.haar.</span>detect_multi_scale
        <span class="apidocSignatureSpan">(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, classifier, scale_factor, scale_min)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect_multi_scale = function (int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, classifier, scale_factor, scale_min) {
    if (typeof scale_factor === "undefined") { scale_factor = 1.2; }
    if (typeof scale_min === "undefined") { scale_min = 1.0; }
    var win_w = classifier.size[0];
    var win_h = classifier.size[1];
    var rects = [];
    while (scale_min * win_w &lt; width &amp;&amp; scale_min * win_h &lt; height) {
        rects = rects.concat(this.detect_single_scale(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, scale_min, classifier
));
        scale_min *= scale_factor;
    }
    return rects;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.haar.detect_single_scale" id="apidoc.element.jsfeat.haar.detect_single_scale">
        function <span class="apidocSignatureSpan">jsfeat.haar.</span>detect_single_scale
        <span class="apidocSignatureSpan">(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, scale, classifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect_single_scale = function (int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, scale, classifier) {
    var win_w = (classifier.size[0] * scale)|0,
        win_h = (classifier.size[1] * scale)|0,
        step_x = (0.5 * scale + 1.5)|0,
        step_y = step_x;
    var i,j,k,x,y,ex=(width-win_w)|0,ey=(height-win_h)|0;
    var w1=(width+1)|0,edge_dens,mean,variance,std;
    var inv_area = 1.0 / (win_w * win_h);
    var stages,stage,trees,tree,sn,tn,fn,found=true,stage_thresh,stage_sum,tree_sum,feature,features;
    var fi_a,fi_b,fi_c,fi_d,fw,fh;

    var ii_a=0,ii_b=win_w,ii_c=win_h*w1,ii_d=ii_c+win_w;
    var edges_thresh = ((win_w*win_h) * 0xff * this.edges_density)|0;
    // if too much gradient we also can skip
    //var edges_thresh_high = ((win_w*win_h) * 0xff * 0.3)|0;

    var rects = [];
    for(y = 0; y &lt; ey; y += step_y) {
        ii_a = y * w1;
        for(x = 0; x &lt; ex; x += step_x, ii_a += step_x) {

            mean =    int_sum[ii_a]
                    - int_sum[ii_a+ii_b]
                    - int_sum[ii_a+ii_c]
                    + int_sum[ii_a+ii_d];

            // canny prune
            if(int_canny_sum) {
                edge_dens = (int_canny_sum[ii_a]
                            - int_canny_sum[ii_a+ii_b]
                            - int_canny_sum[ii_a+ii_c]
                            + int_canny_sum[ii_a+ii_d]);
                if(edge_dens &lt; edges_thresh || mean &lt; 20) {
                    x += step_x, ii_a += step_x;
                    continue;
                }
            }

            mean *= inv_area;
            variance = (int_sqsum[ii_a]
                        - int_sqsum[ii_a+ii_b]
                        - int_sqsum[ii_a+ii_c]
                        + int_sqsum[ii_a+ii_d]) * inv_area - mean * mean;

            std = variance &gt; 0. ? Math.sqrt(variance) : 1;

            stages = classifier.complexClassifiers;
            sn = stages.length;
            found =  true;
            for(i = 0; i &lt; sn; ++i) {
                stage = stages[i];
                stage_thresh = stage.threshold;
                trees = stage.simpleClassifiers;
                tn = trees.length;
                stage_sum = 0;
                for(j = 0; j &lt; tn; ++j) {
                    tree = trees[j];
                    tree_sum = 0;
                    features = tree.features;
                    fn = features.length;
                    if(tree.tilted === 1) {
                        for(k=0; k &lt; fn; ++k) {
                            feature = features[k];
                            fi_a = ~~(x + feature[0] * scale) + ~~(y + feature[1] * scale) * w1;
                            fw = ~~(feature[2] * scale);
                            fh = ~~(feature[3] * scale);
                            fi_b = fw * w1;
                            fi_c =  fh * w1;

                            tree_sum += (int_tilted[fi_a]
                                        - int_tilted[fi_a + fw + fi_b]
                                        - int_tilted[fi_a - fh + fi_c]
                                        + int_tilted[fi_a + fw - fh + fi_b + fi_c]) * feature[4];
                        }
                    } else {
                        for(k=0; k &lt; fn; ++k) {
                            feature = features[k];
                            fi_a = ~~(x + feature[0] * scale) + ~~(y + feature[1] * scale) * w1;
                            fw = ~~(feature[2] * scale);
                            fh = ~~(feature[3] * scale);
                            fi_c = fh * w1;

                            tree_sum += (int_sum[fi_a]
                                        - int_sum[fi_a+fw]
                                        - int_sum[fi_a+fi_c]
                                        + int_sum[fi_a+fi_c+fw]) * feature[4];
                        }
                    }
                    stage_sum += (tree_sum * inv_area &lt; tree.threshold * std) ? tree.left_val : tree.right_val;
                }
                if (stage_sum &lt; stage_thresh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
detect_multi_scale: function(int_sum, int_sqsum, int_tilted, int_canny_sum, width, height, classifier, scale_factor, scale_min) {
    if (typeof scale_factor === "undefined") { scale_factor = 1.2; }
    if (typeof scale_min === "undefined") { scale_min = 1.0; }
    var win_w = classifier.size[0];
    var win_h = classifier.size[1];
    var rects = [];
    while (scale_min * win_w &lt; width &amp;&amp; scale_min * win_h &lt; height) {
        rects = rects.concat(this.<span class="apidocCodeKeywordSpan">detect_single_scale</span>(int_sum, int_sqsum, int_tilted,
int_canny_sum, width, height, scale_min, classifier));
        scale_min *= scale_factor;
    }
    return rects;
},

// OpenCV method to group detected rectangles
group_rectangles: function(rects, min_neighbors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.haar.group_rectangles" id="apidoc.element.jsfeat.haar.group_rectangles">
        function <span class="apidocSignatureSpan">jsfeat.haar.</span>group_rectangles
        <span class="apidocSignatureSpan">(rects, min_neighbors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group_rectangles = function (rects, min_neighbors) {
    if (typeof min_neighbors === "undefined") { min_neighbors = 1; }
    var i, j, n = rects.length;
    var node = [];
    for (i = 0; i &lt; n; ++i) {
        node[i] = {"parent" : -1,
                   "element" : rects[i],
                   "rank" : 0};
    }
    for (i = 0; i &lt; n; ++i) {
        if (!node[i].element)
            continue;
        var root = i;
        while (node[root].parent != -1)
            root = node[root].parent;
        for (j = 0; j &lt; n; ++j) {
            if( i != j &amp;&amp; node[j].element &amp;&amp; _group_func(node[i].element, node[j].element)) {
                var root2 = j;

                while (node[root2].parent != -1)
                    root2 = node[root2].parent;

                if(root2 != root) {
                    if(node[root].rank &gt; node[root2].rank)
                        node[root2].parent = root;
                    else {
                        node[root].parent = root2;
                        if (node[root].rank == node[root2].rank)
                        node[root2].rank++;
                        root = root2;
                    }

                    /* compress path from node2 to the root: */
                    var temp, node2 = j;
                    while (node[node2].parent != -1) {
                        temp = node2;
                        node2 = node[node2].parent;
                        node[temp].parent = root;
                    }

                    /* compress path from node to the root: */
                    node2 = i;
                    while (node[node2].parent != -1) {
                        temp = node2;
                        node2 = node[node2].parent;
                        node[temp].parent = root;
                    }
                }
            }
        }
    }
    var idx_seq = [];
    var class_idx = 0;
    for(i = 0; i &lt; n; i++) {
        j = -1;
        var node1 = i;
        if(node[node1].element) {
            while (node[node1].parent != -1)
                node1 = node[node1].parent;
            if(node[node1].rank &gt;= 0)
                node[node1].rank = ~class_idx++;
            j = ~node[node1].rank;
        }
        idx_seq[i] = j;
    }

    var comps = [];
    for (i = 0; i &lt; class_idx+1; ++i) {
        comps[i] = {"neighbors" : 0,
                    "x" : 0,
                    "y" : 0,
                    "width" : 0,
                    "height" : 0,
                    "confidence" : 0};
    }

    // count number of neighbors
    for(i = 0; i &lt; n; ++i) {
        var r1 = rects[i];
        var idx = idx_seq[i];

        if (comps[idx].neighbors == 0)
            comps[idx].confidence = r1.confidence;

        ++comps[idx].neighbors;

        comps[idx].x += r1.x;
        comps[idx].y += r1.y;
        comps[idx].width += r1.width;
        comps[idx].height += r1.height;
        comps[idx].confidence = Math.max(comps[idx].confidence, r1.confidence);
    }

    var seq2 = [];
    // calculate average bounding box
    for(i = 0; i &lt; class_idx; ++i) {
        n = comps[i].neighbors;
        if (n &gt;= min_neighbors)
            seq2.push({"x" : (comps[i].x * 2 + n) / (2 * n),
                       "y" : (comps[i].y * 2 + n) / (2 * n),
                       "width" : (comps[i].width * 2 + n) / (2 * n),
                       "height" : (comps[i].height * 2 + n) / (2 * n),
                       "neighbors" : comps[i].neighbors,
                       "confidence" : comps[i].confidence});
    }

    var result_seq = [];
    n = seq2.length;
    // filter out small face rectangles inside large face rectangles
    for(i = 0; i &lt; n; ++i) {
        var r1 = seq2[i];
        var flag = true;
        for(j = 0; j &lt; n; ++j) {
            var r2 = seq2[j];
            var distance = (r2.width * 0.25 + 0.5)|0;

            if(i != j &amp;&amp;
               r1.x &gt;= r2.x - distance &amp;&amp;
               r1.y &gt;= r2.y - distance &amp;&amp;
               r1.x + r1.width &lt;= r2.x + r2.width + dista ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.imgproc" id="apidoc.module.jsfeat.imgproc">module jsfeat.imgproc</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.box_blur_gray" id="apidoc.element.jsfeat.imgproc.box_blur_gray">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>box_blur_gray
        <span class="apidocSignatureSpan">(src, dst, radius, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box_blur_gray = function (src, dst, radius, options) {
    if (typeof options === "undefined") { options = 0; }
    var w=src.cols, h=src.rows, h2=h&lt;&lt;1, w2=w&lt;&lt;1;
    var i=0,x=0,y=0,end=0;
    var windowSize = ((radius &lt;&lt; 1) + 1)|0;
    var radiusPlusOne = (radius + 1)|0, radiusPlus2 = (radiusPlusOne+1)|0;
    var scale = options&amp;jsfeat.BOX_BLUR_NOSCALE ? 1 : (1.0 / (windowSize*windowSize));

    var tmp_buff = jsfeat.cache.get_buffer((w*h)&lt;&lt;2);

    var sum=0, dstIndex=0, srcIndex = 0, nextPixelIndex=0, previousPixelIndex=0;
    var data_i32 = tmp_buff.i32; // to prevent overflow
    var data_u8 = src.data;
    var hold=0;

    dst.resize(w, h, src.channel);

    // first pass
    // no need to scale
    //data_u8 = src.data;
    //data_i32 = tmp;
    for (y = 0; y &lt; h; ++y) {
        dstIndex = y;
        sum = radiusPlusOne * data_u8[srcIndex];

        for(i = (srcIndex+1)|0, end=(srcIndex+radius)|0; i &lt;= end; ++i) {
            sum += data_u8[i];
        }

        nextPixelIndex = (srcIndex + radiusPlusOne)|0;
        previousPixelIndex = srcIndex;
        hold = data_u8[previousPixelIndex];
        for(x = 0; x &lt; radius; ++x, dstIndex += h) {
            data_i32[dstIndex] = sum;
            sum += data_u8[nextPixelIndex]- hold;
            nextPixelIndex ++;
        }
        for(; x &lt; w-radiusPlus2; x+=2, dstIndex += h2) {
            data_i32[dstIndex] = sum;
            sum += data_u8[nextPixelIndex]- data_u8[previousPixelIndex];

            data_i32[dstIndex+h] = sum;
            sum += data_u8[nextPixelIndex+1]- data_u8[previousPixelIndex+1];

            nextPixelIndex +=2;
            previousPixelIndex +=2;
        }
        for(; x &lt; w-radiusPlusOne; ++x, dstIndex += h) {
            data_i32[dstIndex] = sum;
            sum += data_u8[nextPixelIndex]- data_u8[previousPixelIndex];

            nextPixelIndex ++;
            previousPixelIndex ++;
        }

        hold = data_u8[nextPixelIndex-1];
        for(; x &lt; w; ++x, dstIndex += h) {
            data_i32[dstIndex] = sum;

            sum += hold- data_u8[previousPixelIndex];
            previousPixelIndex ++;
        }

        srcIndex += w;
    }
    //
    // second pass
    srcIndex = 0;
    //data_i32 = tmp; // this is a transpose
    data_u8 = dst.data;

    // dont scale result
    if(scale == 1) {
        for (y = 0; y &lt; w; ++y) {
            dstIndex = y;
            sum = radiusPlusOne * data_i32[srcIndex];

            for(i = (srcIndex+1)|0, end=(srcIndex+radius)|0; i &lt;= end; ++i) {
                sum += data_i32[i];
            }

            nextPixelIndex = srcIndex + radiusPlusOne;
            previousPixelIndex = srcIndex;
            hold = data_i32[previousPixelIndex];

            for(x = 0; x &lt; radius; ++x, dstIndex += w) {
                data_u8[dstIndex] = sum;
                sum += data_i32[nextPixelIndex]- hold;
                nextPixelIndex ++;
            }
            for(; x &lt; h-radiusPlus2; x+=2, dstIndex += w2) {
                data_u8[dstIndex] = sum;
                sum += data_i32[nextPixelIndex]- data_i32[previousPixelIndex];

                data_u8[dstIndex+w] = sum;
                sum += data_i32[nextPixelIndex+1]- data_i32[previousPixelIndex+1];

                nextPixelIndex +=2;
                previousPixelIndex +=2;
            }
            for(; x &lt; h-radiusPlusOne; ++x, dstIndex += w) {
                data_u8[dstIndex] = sum;

                sum += data_i32[nextPixelIndex]- data_i32[previousPixelIndex];
                nextPixelIndex ++;
                previousPixelIndex ++;
            }
            hold = data_i32[nextPixelIndex-1];
            for(; x &lt; h; ++x, dstIndex += w) {
                data_u8[dstIndex] = sum;

                sum += hold- data_i32[previousPixelIndex];
                previousPixelIndex ++;
            }

            srcIndex += h;
        }
    } else {
        for (y = 0; y &lt; w; ++y) {
            dstIndex = y;
            sum = radiusPlusOne * data_i32[srcIndex];

            for(i = (srcIndex+1)|0, end=(srcIndex+radius)|0; i &lt;= end; ++i) {
                sum += data ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.canny" id="apidoc.element.jsfeat.imgproc.canny">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>canny
        <span class="apidocSignatureSpan">(src, dst, low_thresh, high_thresh)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canny = function (src, dst, low_thresh, high_thresh) {
    var w=src.cols,h=src.rows,src_d=src.data;

    dst.resize(w, h, src.channel);

    var dst_d=dst.data;
    var i=0,j=0,grad=0,w2=w&lt;&lt;1,_grad=0,suppress=0,f=0,x=0,y=0,s=0;
    var tg22x=0,tg67x=0;

    // cache buffers
    var dxdy_node = jsfeat.cache.get_buffer((h * w2)&lt;&lt;2);
    var buf_node = jsfeat.cache.get_buffer((3 * (w + 2))&lt;&lt;2);
    var map_node = jsfeat.cache.get_buffer(((h+2) * (w + 2))&lt;&lt;2);
    var stack_node = jsfeat.cache.get_buffer((h * w)&lt;&lt;2);


    var buf = buf_node.i32;
    var map = map_node.i32;
    var stack = stack_node.i32;
    var dxdy = dxdy_node.i32;
    var dxdy_m = new jsfeat.matrix_t(w, h, jsfeat.S32C2_t, dxdy_node.data);
    var row0=1,row1=(w+2+1)|0,row2=(2*(w+2)+1)|0,map_w=(w+2)|0,map_i=(map_w+1)|0,stack_i=0;

    this.sobel_derivatives(src, dxdy_m);

    if(low_thresh &gt; high_thresh) {
        i = low_thresh;
        low_thresh = high_thresh;
        high_thresh = i;
    }

    i = (3 * (w + 2))|0;
    while(--i&gt;=0) {
        buf[i] = 0;
    }

    i = ((h+2) * (w + 2))|0;
    while(--i&gt;=0) {
        map[i] = 0;
    }

    for (; j &lt; w; ++j, grad+=2) {
        //buf[row1+j] = Math.abs(dxdy[grad]) + Math.abs(dxdy[grad+1]);
        x = dxdy[grad], y = dxdy[grad+1];
        //buf[row1+j] = x*x + y*y;
        buf[row1+j] = ((x ^ (x &gt;&gt; 31)) - (x &gt;&gt; 31)) + ((y ^ (y &gt;&gt; 31)) - (y &gt;&gt; 31));
    }

    for(i=1; i &lt;= h; ++i, grad+=w2) {
        if(i == h) {
            j = row2+w;
            while(--j&gt;=row2) {
                buf[j] = 0;
            }
        } else {
            for (j = 0; j &lt; w; j++) {
                //buf[row2+j] =  Math.abs(dxdy[grad+(j&lt;&lt;1)]) + Math.abs(dxdy[grad+(j&lt;&lt;1)+1]);
                x = dxdy[grad+(j&lt;&lt;1)], y = dxdy[grad+(j&lt;&lt;1)+1];
                //buf[row2+j] = x*x + y*y;
                buf[row2+j] = ((x ^ (x &gt;&gt; 31)) - (x &gt;&gt; 31)) + ((y ^ (y &gt;&gt; 31)) - (y &gt;&gt; 31));
            }
        }
        _grad = (grad - w2)|0;
        map[map_i-1] = 0;
        suppress = 0;
        for(j = 0; j &lt; w; ++j, _grad+=2) {
            f = buf[row1+j];
            if (f &gt; low_thresh) {
                x = dxdy[_grad];
                y = dxdy[_grad+1];
                s = x ^ y;
                // seems ot be faster than Math.abs
                x = ((x ^ (x &gt;&gt; 31)) - (x &gt;&gt; 31))|0;
                y = ((y ^ (y &gt;&gt; 31)) - (y &gt;&gt; 31))|0;
                //x * tan(22.5) x * tan(67.5) == 2 * x + x * tan(22.5)
                tg22x = x * 13573;
                tg67x = tg22x + ((x + x) &lt;&lt; 15);
                y &lt;&lt;= 15;
                if (y &lt; tg22x) {
                    if (f &gt; buf[row1+j-1] &amp;&amp; f &gt;= buf[row1+j+1]) {
                        if (f &gt; high_thresh &amp;&amp; !suppress &amp;&amp; map[map_i+j-map_w] != 2) {
                            map[map_i+j] = 2;
                            suppress = 1;
                            stack[stack_i++] = map_i + j;
                        } else {
                            map[map_i+j] = 1;
                        }
                        continue;
                    }
                } else if (y &gt; tg67x) {
                    if (f &gt; buf[row0+j] &amp;&amp; f &gt;= buf[row2+j]) {
                        if (f &gt; high_thresh &amp;&amp; !suppress &amp;&amp; map[map_i+j-map_w] != 2) {
                            map[map_i+j] = 2;
                            suppress = 1;
                            stack[stack_i++] = map_i + j;
                        } else {
                            map[map_i+j] = 1;
                        }
                        continue;
                    }
                } else {
                    s = s &lt; 0 ? -1 : 1;
                    if (f &gt; buf[row0+j-s] &amp;&amp; f &gt; buf[row2+j+s]) {
                        if (f &gt; high_thresh &amp;&amp; !suppress &amp;&amp; map[map_i+j-map_w] != 2) {
                            map[map_i+j] = 2;
                            suppress = 1;
                            stack[stack_i++] = map_i + j;
                        } else {
                            map[map_i+j] = 1;
                        }
                        continue;
                    }
                }
            } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.compute_integral_image" id="apidoc.element.jsfeat.imgproc.compute_integral_image">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>compute_integral_image
        <span class="apidocSignatureSpan">(src, dst_sum, dst_sqsum, dst_tilted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compute_integral_image = function (src, dst_sum, dst_sqsum, dst_tilted) {
    var w0=src.cols|0,h0=src.rows|0,src_d=src.data;
    var w1=(w0+1)|0;
    var s=0,s2=0,p=0,pup=0,i=0,j=0,v=0,k=0;

    if(dst_sum &amp;&amp; dst_sqsum) {
        // fill first row with zeros
        for(; i &lt; w1; ++i) {
            dst_sum[i] = 0, dst_sqsum[i] = 0;
        }
        p = (w1+1)|0, pup = 1;
        for(i = 0, k = 0; i &lt; h0; ++i, ++p, ++pup) {
            s = s2 = 0;
            for(j = 0; j &lt;= w0-2; j+=2, k+=2, p+=2, pup+=2) {
                v = src_d[k];
                s += v, s2 += v*v;
                dst_sum[p] = dst_sum[pup] + s;
                dst_sqsum[p] = dst_sqsum[pup] + s2;

                v = src_d[k+1];
                s += v, s2 += v*v;
                dst_sum[p+1] = dst_sum[pup+1] + s;
                dst_sqsum[p+1] = dst_sqsum[pup+1] + s2;
            }
            for(; j &lt; w0; ++j, ++k, ++p, ++pup) {
                v = src_d[k];
                s += v, s2 += v*v;
                dst_sum[p] = dst_sum[pup] + s;
                dst_sqsum[p] = dst_sqsum[pup] + s2;
            }
        }
    } else if(dst_sum) {
        // fill first row with zeros
        for(; i &lt; w1; ++i) {
            dst_sum[i] = 0;
        }
        p = (w1+1)|0, pup = 1;
        for(i = 0, k = 0; i &lt; h0; ++i, ++p, ++pup) {
            s = 0;
            for(j = 0; j &lt;= w0-2; j+=2, k+=2, p+=2, pup+=2) {
                s += src_d[k];
                dst_sum[p] = dst_sum[pup] + s;
                s += src_d[k+1];
                dst_sum[p+1] = dst_sum[pup+1] + s;
            }
            for(; j &lt; w0; ++j, ++k, ++p, ++pup) {
                s += src_d[k];
                dst_sum[p] = dst_sum[pup] + s;
            }
        }
    } else if(dst_sqsum) {
        // fill first row with zeros
        for(; i &lt; w1; ++i) {
            dst_sqsum[i] = 0;
        }
        p = (w1+1)|0, pup = 1;
        for(i = 0, k = 0; i &lt; h0; ++i, ++p, ++pup) {
            s2 = 0;
            for(j = 0; j &lt;= w0-2; j+=2, k+=2, p+=2, pup+=2) {
                v = src_d[k];
                s2 += v*v;
                dst_sqsum[p] = dst_sqsum[pup] + s2;
                v = src_d[k+1];
                s2 += v*v;
                dst_sqsum[p+1] = dst_sqsum[pup+1] + s2;
            }
            for(; j &lt; w0; ++j, ++k, ++p, ++pup) {
                v = src_d[k];
                s2 += v*v;
                dst_sqsum[p] = dst_sqsum[pup] + s2;
            }
        }
    }

    if(dst_tilted) {
        // fill first row with zeros
        for(i = 0; i &lt; w1; ++i) {
            dst_tilted[i] = 0;
        }
        // diagonal
        p = (w1+1)|0, pup = 0;
        for(i = 0, k = 0; i &lt; h0; ++i, ++p, ++pup) {
            for(j = 0; j &lt;= w0-2; j+=2, k+=2, p+=2, pup+=2) {
                dst_tilted[p] = src_d[k] + dst_tilted[pup];
                dst_tilted[p+1] = src_d[k+1] + dst_tilted[pup+1];
            }
            for(; j &lt; w0; ++j, ++k, ++p, ++pup) {
                dst_tilted[p] = src_d[k] + dst_tilted[pup];
            }
        }
        // diagonal
        p = (w1+w0)|0, pup = w0;
        for(i = 0; i &lt; h0; ++i, p+=w1, pup+=w1) {
            dst_tilted[p] += dst_tilted[pup];
        }

        for(j = w0-1; j &gt; 0; --j) {
            p = j+h0*w1, pup=p-w1;
            for(i = h0; i &gt; 0; --i, p-=w1, pup-=w1) {
                dst_tilted[p] += dst_tilted[pup] + dst_tilted[pup+1];
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.equalize_histogram" id="apidoc.element.jsfeat.imgproc.equalize_histogram">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>equalize_histogram
        <span class="apidocSignatureSpan">(src, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equalize_histogram = function (src, dst) {
    var w=src.cols,h=src.rows,src_d=src.data;

    dst.resize(w, h, src.channel);

    var dst_d=dst.data,size=w*h;
    var i=0,prev=0,hist0,norm;

    var hist0_node = jsfeat.cache.get_buffer(256&lt;&lt;2);
    hist0 = hist0_node.i32;
    for(; i &lt; 256; ++i) hist0[i] = 0;
    for (i = 0; i &lt; size; ++i) {
        ++hist0[src_d[i]];
    }

    prev = hist0[0];
    for (i = 1; i &lt; 256; ++i) {
        prev = hist0[i] += prev;
    }

    norm = 255 / size;
    for (i = 0; i &lt; size; ++i) {
        dst_d[i] = (hist0[src_d[i]] * norm + 0.5)|0;
    }
    jsfeat.cache.put_buffer(hist0_node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.gaussian_blur" id="apidoc.element.jsfeat.imgproc.gaussian_blur">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>gaussian_blur
        <span class="apidocSignatureSpan">(src, dst, kernel_size, sigma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gaussian_blur = function (src, dst, kernel_size, sigma) {
    if (typeof sigma === "undefined") { sigma = 0.0; }
    if (typeof kernel_size === "undefined") { kernel_size = 0; }
    kernel_size = kernel_size == 0 ? (Math.max(1, (4.0 * sigma + 1.0 - 1e-8)) * 2 + 1)|0 : kernel_size;
    var half_kernel = kernel_size &gt;&gt; 1;
    var w = src.cols, h = src.rows;
    var data_type = src.type, is_u8 = data_type&amp;jsfeat.U8_t;

    dst.resize(w, h, src.channel);

    var src_d = src.data, dst_d = dst.data;
    var buf,filter,buf_sz=(kernel_size + Math.max(h, w))|0;

    var buf_node = jsfeat.cache.get_buffer(buf_sz&lt;&lt;2);
    var filt_node = jsfeat.cache.get_buffer(kernel_size&lt;&lt;2);

    if(is_u8) {
        buf = buf_node.i32;
        filter = filt_node.i32;
    } else if(data_type&amp;jsfeat.S32_t) {
        buf = buf_node.i32;
        filter = filt_node.f32;
    } else {
        buf = buf_node.f32;
        filter = filt_node.f32;
    }

    jsfeat.math.get_gaussian_kernel(kernel_size, sigma, filter, data_type);

    if(is_u8) {
        _convol_u8(buf, src_d, dst_d, w, h, filter, kernel_size, half_kernel);
    } else {
        _convol(buf, src_d, dst_d, w, h, filter, kernel_size, half_kernel);
    }

    jsfeat.cache.put_buffer(buf_node);
    jsfeat.cache.put_buffer(filt_node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.grayscale" id="apidoc.element.jsfeat.imgproc.grayscale">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>grayscale
        <span class="apidocSignatureSpan">(src, w, h, dst, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grayscale = function (src, w, h, dst, code) {
    // this is default image data representation in browser
    if (typeof code === "undefined") { code = jsfeat.COLOR_RGBA2GRAY; }
    var x=0, y=0, i=0, j=0, ir=0,jr=0;
    var coeff_r = 4899, coeff_g = 9617, coeff_b = 1868, cn = 4;

    if(code == jsfeat.COLOR_BGRA2GRAY || code == jsfeat.COLOR_BGR2GRAY) {
        coeff_r = 1868;
        coeff_b = 4899;
    }
    if(code == jsfeat.COLOR_RGB2GRAY || code == jsfeat.COLOR_BGR2GRAY) {
        cn = 3;
    }
    var cn2 = cn&lt;&lt;1, cn3 = (cn*3)|0;

    dst.resize(w, h, 1);
    var dst_u8 = dst.data;

    for(y = 0; y &lt; h; ++y, j+=w, i+=w*cn) {
        for(x = 0, ir = i, jr = j; x &lt;= w-4; x+=4, ir+=cn&lt;&lt;2, jr+=4) {
            dst_u8[jr]     = (src[ir] * coeff_r + src[ir+1] * coeff_g + src[ir+2] * coeff_b + 8192) &gt;&gt; 14;
            dst_u8[jr + 1] = (src[ir+cn] * coeff_r + src[ir+cn+1] * coeff_g + src[ir+cn+2] * coeff_b + 8192) &gt;&gt; 14;
            dst_u8[jr + 2] = (src[ir+cn2] * coeff_r + src[ir+cn2+1] * coeff_g + src[ir+cn2+2] * coeff_b + 8192) &gt;&gt; 14;
            dst_u8[jr + 3] = (src[ir+cn3] * coeff_r + src[ir+cn3+1] * coeff_g + src[ir+cn3+2] * coeff_b + 8192) &gt;&gt; 14;
        }
        for (; x &lt; w; ++x, ++jr, ir+=cn) {
            dst_u8[jr] = (src[ir] * coeff_r + src[ir+1] * coeff_g + src[ir+2] * coeff_b + 8192) &gt;&gt; 14;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.pyrdown" id="apidoc.element.jsfeat.imgproc.pyrdown">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>pyrdown
        <span class="apidocSignatureSpan">(src, dst, sx, sy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pyrdown = function (src, dst, sx, sy) {
    // this is needed for bbf
    if (typeof sx === "undefined") { sx = 0; }
    if (typeof sy === "undefined") { sy = 0; }

    var w = src.cols, h = src.rows;
    var w2 = w &gt;&gt; 1, h2 = h &gt;&gt; 1;
    var _w2 = w2 - (sx &lt;&lt; 1), _h2 = h2 - (sy &lt;&lt; 1);
    var x=0,y=0,sptr=sx+sy*w,sline=0,dptr=0,dline=0;

    dst.resize(w2, h2, src.channel);

    var src_d = src.data, dst_d = dst.data;

    for(y = 0; y &lt; _h2; ++y) {
        sline = sptr;
        dline = dptr;
        for(x = 0; x &lt;= _w2-2; x+=2, dline+=2, sline += 4) {
            dst_d[dline] = (src_d[sline] + src_d[sline+1] +
                                src_d[sline+w] + src_d[sline+w+1] + 2) &gt;&gt; 2;
            dst_d[dline+1] = (src_d[sline+2] + src_d[sline+3] +
                                src_d[sline+w+2] + src_d[sline+w+3] + 2) &gt;&gt; 2;
        }
        for(; x &lt; _w2; ++x, ++dline, sline += 2) {
            dst_d[dline] = (src_d[sline] + src_d[sline+1] +
                                src_d[sline+w] + src_d[sline+w+1] + 2) &gt;&gt; 2;
        }
        sptr += w &lt;&lt; 1;
        dptr += w2;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(!skip_first_level) {
        var j=input.cols*input.rows;
        while(--j &gt;= 0) {
            b.data[j] = input.data[j];
        }
    }
    b = this.data[1];
    this.<span class="apidocCodeKeywordSpan">pyrdown</span>(a, b);
    for(; i &lt; this.levels; ++i) {
        a = b;
        b = this.data[i];
        this.pyrdown(a, b);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.resample" id="apidoc.element.jsfeat.imgproc.resample">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>resample
        <span class="apidocSignatureSpan">(src, dst, nw, nh)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resample = function (src, dst, nw, nh) {
    var h=src.rows,w=src.cols;
    if (h &gt; nh &amp;&amp; w &gt; nw) {
        dst.resize(nw, nh, src.channel);
        // using the fast alternative (fix point scale, 0x100 to avoid overflow)
        if (src.type&amp;jsfeat.U8_t &amp;&amp; dst.type&amp;jsfeat.U8_t &amp;&amp; h * w / (nh * nw) &lt; 0x100) {
            _resample_u8(src, dst, nw, nh);
        } else {
            _resample(src, dst, nw, nh);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    nw = (sw / Math.pow(this.scale, i))|0;
    nh = (sh / Math.pow(this.scale, i))|0;
    src0 = img_pyr.data[i&lt;&lt;2];
    if(new_pyr || nw != src0.cols || nh != src0.rows) {
        img_pyr.data[i&lt;&lt;2] = new jsfeat.matrix_t(nw, nh, data_type);
        src0 = img_pyr.data[i&lt;&lt;2];
    }
    jsfeat.imgproc.<span class="apidocCodeKeywordSpan">resample</span>(src, src0, nw, nh);
}
for (i = this.next; i &lt; this.scale_to + this.next * 2; ++i) {
    src1 = img_pyr.data[(i &lt;&lt; 2) - (this.next &lt;&lt; 2)];
    src0 = img_pyr.data[i&lt;&lt;2];
    nw = src1.cols &gt;&gt; 1;
    nh = src1.rows &gt;&gt; 1;
    if(new_pyr || nw != src0.cols || nh != src0.rows) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.scharr_derivatives" id="apidoc.element.jsfeat.imgproc.scharr_derivatives">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>scharr_derivatives
        <span class="apidocSignatureSpan">(src, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scharr_derivatives = function (src, dst) {
    var w = src.cols, h = src.rows;
    var dstep = w&lt;&lt;1,x=0,y=0,x1=0,a,b,c,d,e,f;
    var srow0=0,srow1=0,srow2=0,drow=0;
    var trow0,trow1;

    dst.resize(w, h, 2); // 2 channel output gx, gy

    var img = src.data, gxgy=dst.data;

    var buf0_node = jsfeat.cache.get_buffer((w+2)&lt;&lt;2);
    var buf1_node = jsfeat.cache.get_buffer((w+2)&lt;&lt;2);

    if(src.type&amp;jsfeat.U8_t || src.type&amp;jsfeat.S32_t) {
        trow0 = buf0_node.i32;
        trow1 = buf1_node.i32;
    } else {
        trow0 = buf0_node.f32;
        trow1 = buf1_node.f32;
    }

    for(; y &lt; h; ++y, srow1+=w) {
        srow0 = ((y &gt; 0 ? y-1 : 1)*w)|0;
        srow2 = ((y &lt; h-1 ? y+1 : h-2)*w)|0;
        drow = (y*dstep)|0;
        // do vertical convolution
        for(x = 0, x1 = 1; x &lt;= w-2; x+=2, x1+=2) {
            a = img[srow0+x], b = img[srow2+x];
            trow0[x1] = ( (a + b)*3 + (img[srow1+x])*10 );
            trow1[x1] = ( b - a );
            //
            a = img[srow0+x+1], b = img[srow2+x+1];
            trow0[x1+1] = ( (a + b)*3 + (img[srow1+x+1])*10 );
            trow1[x1+1] = ( b - a );
        }
        for(; x &lt; w; ++x, ++x1) {
            a = img[srow0+x], b = img[srow2+x];
            trow0[x1] = ( (a + b)*3 + (img[srow1+x])*10 );
            trow1[x1] = ( b - a );
        }
        // make border
        x = (w + 1)|0;
        trow0[0] = trow0[1]; trow0[x] = trow0[w];
        trow1[0] = trow1[1]; trow1[x] = trow1[w];
        // do horizontal convolution, interleave the results and store them
        for(x = 0; x &lt;= w-4; x+=4) {
            a = trow1[x+2], b = trow1[x+1], c = trow1[x+3], d = trow1[x+4],
            e = trow0[x+2], f = trow0[x+3];
            gxgy[drow++] = ( e - trow0[x] );
            gxgy[drow++] = ( (a + trow1[x])*3 + b*10 );
            gxgy[drow++] = ( f - trow0[x+1] );
            gxgy[drow++] = ( (c + b)*3 + a*10 );

            gxgy[drow++] = ( (trow0[x+4] - e) );
            gxgy[drow++] = ( ((d + a)*3 + c*10) );
            gxgy[drow++] = ( (trow0[x+5] - f) );
            gxgy[drow++] = ( ((trow1[x+5] + c)*3 + d*10) );
        }
        for(; x &lt; w; ++x) {
            gxgy[drow++] = ( (trow0[x+2] - trow0[x]) );
            gxgy[drow++] = ( ((trow1[x+2] + trow1[x])*3 + trow1[x+1]*10) );
        }
    }
    jsfeat.cache.put_buffer(buf0_node);
    jsfeat.cache.put_buffer(buf1_node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.skindetector" id="apidoc.element.jsfeat.imgproc.skindetector">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>skindetector
        <span class="apidocSignatureSpan">(src, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skindetector = function (src, dst) {
    var r,g,b,j;
    var i = src.width*src.height;
    while(i--){
        j = i*4;
        r = src.data[j];
        g = src.data[j+1];
        b = src.data[j+2];
        if((r&gt;95)&amp;&amp;(g&gt;40)&amp;&amp;(b&gt;20)
         &amp;&amp;(r&gt;g)&amp;&amp;(r&gt;b)
         &amp;&amp;(r-Math.min(g,b)&gt;15)
         &amp;&amp;(Math.abs(r-g)&gt;15)){
             dst[i] = 255;
        } else {
            dst[i] = 0;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.sobel_derivatives" id="apidoc.element.jsfeat.imgproc.sobel_derivatives">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>sobel_derivatives
        <span class="apidocSignatureSpan">(src, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sobel_derivatives = function (src, dst) {
    var w = src.cols, h = src.rows;
    var dstep = w&lt;&lt;1,x=0,y=0,x1=0,a,b,c,d,e,f;
    var srow0=0,srow1=0,srow2=0,drow=0;
    var trow0,trow1;

    dst.resize(w, h, 2); // 2 channel output gx, gy

    var img = src.data, gxgy=dst.data;

    var buf0_node = jsfeat.cache.get_buffer((w+2)&lt;&lt;2);
    var buf1_node = jsfeat.cache.get_buffer((w+2)&lt;&lt;2);

    if(src.type&amp;jsfeat.U8_t || src.type&amp;jsfeat.S32_t) {
        trow0 = buf0_node.i32;
        trow1 = buf1_node.i32;
    } else {
        trow0 = buf0_node.f32;
        trow1 = buf1_node.f32;
    }

    for(; y &lt; h; ++y, srow1+=w) {
        srow0 = ((y &gt; 0 ? y-1 : 1)*w)|0;
        srow2 = ((y &lt; h-1 ? y+1 : h-2)*w)|0;
        drow = (y*dstep)|0;
        // do vertical convolution
        for(x = 0, x1 = 1; x &lt;= w-2; x+=2, x1+=2) {
            a = img[srow0+x], b = img[srow2+x];
            trow0[x1] = ( (a + b) + (img[srow1+x]*2) );
            trow1[x1] = ( b - a );
            //
            a = img[srow0+x+1], b = img[srow2+x+1];
            trow0[x1+1] = ( (a + b) + (img[srow1+x+1]*2) );
            trow1[x1+1] = ( b - a );
        }
        for(; x &lt; w; ++x, ++x1) {
            a = img[srow0+x], b = img[srow2+x];
            trow0[x1] = ( (a + b) + (img[srow1+x]*2) );
            trow1[x1] = ( b - a );
        }
        // make border
        x = (w + 1)|0;
        trow0[0] = trow0[1]; trow0[x] = trow0[w];
        trow1[0] = trow1[1]; trow1[x] = trow1[w];
        // do horizontal convolution, interleave the results and store them
        for(x = 0; x &lt;= w-4; x+=4) {
            a = trow1[x+2], b = trow1[x+1], c = trow1[x+3], d = trow1[x+4],
            e = trow0[x+2], f = trow0[x+3];
            gxgy[drow++] = ( e - trow0[x] );
            gxgy[drow++] = ( a + trow1[x] + b*2 );
            gxgy[drow++] = ( f - trow0[x+1] );
            gxgy[drow++] = ( c + b + a*2 );

            gxgy[drow++] = ( trow0[x+4] - e );
            gxgy[drow++] = ( d + a + c*2 );
            gxgy[drow++] = ( trow0[x+5] - f );
            gxgy[drow++] = ( trow1[x+5] + c + d*2 );
        }
        for(; x &lt; w; ++x) {
            gxgy[drow++] = ( trow0[x+2] - trow0[x] );
            gxgy[drow++] = ( trow1[x+2] + trow1[x] + trow1[x+1]*2 );
        }
    }
    jsfeat.cache.put_buffer(buf0_node);
    jsfeat.cache.put_buffer(buf1_node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var buf = buf_node.i32;
var map = map_node.i32;
var stack = stack_node.i32;
var dxdy = dxdy_node.i32;
var dxdy_m = new jsfeat.matrix_t(w, h, jsfeat.S32C2_t, dxdy_node.data);
var row0=1,row1=(w+2+1)|0,row2=(2*(w+2)+1)|0,map_w=(w+2)|0,map_i=(map_w+1)|0,stack_i=0;

this.<span class="apidocCodeKeywordSpan">sobel_derivatives</span>(src, dxdy_m);

if(low_thresh &gt; high_thresh) {
    i = low_thresh;
    low_thresh = high_thresh;
    high_thresh = i;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.warp_affine" id="apidoc.element.jsfeat.imgproc.warp_affine">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>warp_affine
        <span class="apidocSignatureSpan">(src, dst, transform, fill_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warp_affine = function (src, dst, transform, fill_value) {
    if (typeof fill_value === "undefined") { fill_value = 0; }
    var src_width=src.cols, src_height=src.rows, dst_width=dst.cols, dst_height=dst.rows;
    var src_d=src.data, dst_d=dst.data;
    var x=0,y=0,off=0,ixs=0,iys=0,xs=0.0,ys=0.0,a=0.0,b=0.0,p0=0.0,p1=0.0;
    var td=transform.data;
    var m00=td[0],m01=td[1],m02=td[2],
        m10=td[3],m11=td[4],m12=td[5];

    for(var dptr = 0; y &lt; dst_height; ++y) {
        xs = m01 * y + m02;
        ys = m11 * y + m12;
        for(x = 0; x &lt; dst_width; ++x, ++dptr, xs+=m00, ys+=m10) {
            ixs = xs | 0; iys = ys | 0;

            if(ixs &gt;= 0 &amp;&amp; iys &gt;= 0 &amp;&amp; ixs &lt; (src_width - 1) &amp;&amp; iys &lt; (src_height - 1)) {
                a = xs - ixs;
                b = ys - iys;
                off = src_width*iys + ixs;

                p0 = src_d[off] +  a * (src_d[off+1] - src_d[off]);
                p1 = src_d[off+src_width] + a * (src_d[off+src_width+1] - src_d[off+src_width]);

                dst_d[dptr] = p0 + b * (p1 - p0);
            }
            else dst_d[dptr] = fill_value;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	    var rectify_patch = function(src, dst, angle, px, py, psize) {
	    	var cosine = Math.cos(angle);
	    	var sine   = Math.sin(angle);

	        H.data[0] = cosine, H.data[1] = -sine,    H.data[2] = (-cosine + sine  ) * psize*0.5 + px,
	        H.data[3] = sine,   H.data[4] =  cosine,  H.data[5] = (-sine   - cosine) * psize*0.5 + py;

	        jsfeat.imgproc.<span class="apidocCodeKeywordSpan">warp_affine</span>(src, dst, H, 128);
	    }

    	return {

    		describe: function(src, corners, count, descriptors) {
    			var DESCR_SIZE = 32; // bytes;
				var i=0,b=0,px=0.0,py=0.0,angle=0.0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.imgproc.warp_perspective" id="apidoc.element.jsfeat.imgproc.warp_perspective">
        function <span class="apidocSignatureSpan">jsfeat.imgproc.</span>warp_perspective
        <span class="apidocSignatureSpan">(src, dst, transform, fill_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warp_perspective = function (src, dst, transform, fill_value) {
    if (typeof fill_value === "undefined") { fill_value = 0; }
    var src_width=src.cols|0, src_height=src.rows|0, dst_width=dst.cols|0, dst_height=dst.rows|0;
    var src_d=src.data, dst_d=dst.data;
    var x=0,y=0,off=0,ixs=0,iys=0,xs=0.0,ys=0.0,xs0=0.0,ys0=0.0,ws=0.0,sc=0.0,a=0.0,b=0.0,p0=0.0,p1=0.0;
    var td=transform.data;
    var m00=td[0],m01=td[1],m02=td[2],
        m10=td[3],m11=td[4],m12=td[5],
        m20=td[6],m21=td[7],m22=td[8];

    for(var dptr = 0; y &lt; dst_height; ++y) {
        xs0 = m01 * y + m02,
        ys0 = m11 * y + m12,
        ws  = m21 * y + m22;
        for(x = 0; x &lt; dst_width; ++x, ++dptr, xs0+=m00, ys0+=m10, ws+=m20) {
            sc = 1.0 / ws;
            xs = xs0 * sc, ys = ys0 * sc;
            ixs = xs | 0, iys = ys | 0;

            if(xs &gt; 0 &amp;&amp; ys &gt; 0 &amp;&amp; ixs &lt; (src_width - 1) &amp;&amp; iys &lt; (src_height - 1)) {
                a = Math.max(xs - ixs, 0.0);
                b = Math.max(ys - iys, 0.0);
                off = (src_width*iys + ixs)|0;

                p0 = src_d[off] +  a * (src_d[off+1] - src_d[off]);
                p1 = src_d[off+src_width] + a * (src_d[off+src_width+1] - src_d[off+src_width]);

                dst_d[dptr] = p0 + b * (p1 - p0);
            }
            else dst_d[dptr] = fill_value;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.linalg" id="apidoc.module.jsfeat.linalg">module jsfeat.linalg</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.linalg.cholesky_solve" id="apidoc.element.jsfeat.linalg.cholesky_solve">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>cholesky_solve
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cholesky_solve = function (A, B) {
    var col=0,row=0,col2=0,cs=0,rs=0,i=0,j=0;
    var size = A.cols;
    var ad=A.data, bd=B.data;
    var val,inv_diag;

    for (col = 0; col &lt; size; col++) {
        inv_diag = 1.0;
        cs = (col * size);
        rs = cs;
        for (row = col; row &lt; size; row++)
        {
            // correct for the parts of cholesky already computed
            val = ad[(rs+col)];
            for (col2 = 0; col2 &lt; col; col2++) {
                val -= ad[(col2*size+col)] * ad[(rs+col2)];
            }
            if (row == col) {
                // this is the diagonal element so don't divide
                ad[(rs+col)] = val;
                if(val == 0) {
                    return 0;
                }
                inv_diag = 1.0 / val;
            } else {
                // cache the value without division in the upper half
                ad[(cs+row)] = val;
                // divide my the diagonal element for all others
                ad[(rs+col)] = val * inv_diag;
            }
            rs = (rs + size);
        }
    }

    // first backsub through L
    cs = 0;
    for (i = 0; i &lt; size; i++) {
        val = bd[i];
        for (j = 0; j &lt; i; j++) {
            val -= ad[(cs+j)] * bd[j];
        }
        bd[i] = val;
        cs = (cs + size);
    }
    // backsub through diagonal
    cs = 0;
    for (i = 0; i &lt; size; i++) {
        bd[i] /= ad[(cs + i)];
        cs = (cs + size);
    }
    // backsub through L Transpose
    i = (size-1);
    for (; i &gt;= 0; i--) {
        val = bd[i];
        j = (i + 1);
        cs = (j * size);
        for (; j &lt; size; j++) {
            val -= ad[(cs + i)] * bd[j];
            cs = (cs + size);
        }
        bd[i] = val;
    }

    return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.linalg.eigenVV" id="apidoc.element.jsfeat.linalg.eigenVV">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>eigenVV
        <span class="apidocSignatureSpan">(A, vects, vals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eigenVV = function (A, vects, vals) {
    var n=A.cols,i=n*n;
    var dt = A.type | jsfeat.C1_t;

    var a_buff = jsfeat.cache.get_buffer((n*n)&lt;&lt;3);
    var w_buff = jsfeat.cache.get_buffer(n&lt;&lt;3);
    var a_mt = new jsfeat.matrix_t(n, n, dt, a_buff.data);
    var w_mt = new jsfeat.matrix_t(1, n, dt, w_buff.data);

    while(--i &gt;= 0) {
        a_mt.data[i] = A.data[i];
    }

    JacobiImpl(a_mt.data, n, w_mt.data, vects ? vects.data : null, n, n);

    if(vals) {
        while(--n &gt;= 0) {
            vals.data[n] = w_mt.data[n];
        }
    }

    jsfeat.cache.put_buffer(a_buff);
    jsfeat.cache.put_buffer(w_buff);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

				// symmetry
			    for(i = 0; i &lt; 9; ++i) {
			        for(j = 0; j &lt; i; ++j)
			            LtL[i*9+j] = LtL[j*9+i];
			    }

				jsfeat.linalg.<span class="apidocCodeKeywordSpan">eigenVV</span>(mLtL, Evec);

				md[0]=evd[72], md[1]=evd[73], md[2]=evd[74];
			    md[3]=evd[75], md[4]=evd[76], md[5]=evd[77];
			    md[6]=evd[78], md[7]=evd[79], md[8]=evd[80];

				// denormalize
			    jsfeat.matmath.multiply_3x3(model, T1, model);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.linalg.lu_solve" id="apidoc.element.jsfeat.linalg.lu_solve">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>lu_solve
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lu_solve = function (A, B) {
    var i=0,j=0,k=0,p=1,astep=A.cols;
    var ad=A.data, bd=B.data;
    var t,alpha,d,s;

    for(i = 0; i &lt; astep; i++) {
        k = i;
        for(j = i+1; j &lt; astep; j++) {
            if(Math.abs(ad[j*astep + i]) &gt; Math.abs(ad[k*astep+i])) {
                k = j;
            }
        }

        if(Math.abs(ad[k*astep+i]) &lt; jsfeat.EPSILON) {
            return 0; // FAILED
        }

        if(k != i) {
            for(j = i; j &lt; astep; j++ ) {
                swap(ad, i*astep+j, k*astep+j, t);
            }

            swap(bd, i, k, t);
            p = -p;
        }

        d = -1.0/ad[i*astep+i];

        for(j = i+1; j &lt; astep; j++) {
            alpha = ad[j*astep+i]*d;

            for(k = i+1; k &lt; astep; k++) {
                ad[j*astep+k] += alpha*ad[i*astep+k];
            }

            bd[j] += alpha*bd[i];
        }

        ad[i*astep+i] = -d;
    }

    for(i = astep-1; i &gt;= 0; i--) {
        s = bd[i];
        for(k = i+1; k &lt; astep; k++) {
            s -= ad[i*astep+k]*bd[k];
        }
        bd[i] = s*ad[i*astep+i];
    }

    return 1; // OK
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        bd[i&lt;&lt;1] = t1d[0]*pt1.x + t1d[1]*pt1.y + t1d[2];
			        bd[(i&lt;&lt;1)+1] = t1d[3]*pt1.x + t1d[4]*pt1.y + t1d[5];
			    }

			    jsfeat.matmath.multiply_AtA(AtA, a_mt);
			    jsfeat.matmath.multiply_AtB(AtB, a_mt, b_mt);

			    jsfeat.linalg.<span class="apidocCodeKeywordSpan">lu_solve</span>(AtA, AtB);

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row

			    // denormalize
			    jsfeat.matmath.invert_3x3(T1, T1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.linalg.svd_decompose" id="apidoc.element.jsfeat.linalg.svd_decompose">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_decompose
        <span class="apidocSignatureSpan">(A, W, U, V, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">svd_decompose = function (A, W, U, V, options) {
    if (typeof options === "undefined") { options = 0; };
    var at=0,i=0,j=0,_m=A.rows,_n=A.cols,m=_m,n=_n;
    var dt = A.type | jsfeat.C1_t; // we only work with single channel

    if(m &lt; n) {
        at = 1;
        i = m;
        m = n;
        n = i;
    }

    var a_buff = jsfeat.cache.get_buffer((m*m)&lt;&lt;3);
    var w_buff = jsfeat.cache.get_buffer(n&lt;&lt;3);
    var v_buff = jsfeat.cache.get_buffer((n*n)&lt;&lt;3);

    var a_mt = new jsfeat.matrix_t(m, m, dt, a_buff.data);
    var w_mt = new jsfeat.matrix_t(1, n, dt, w_buff.data);
    var v_mt = new jsfeat.matrix_t(n, n, dt, v_buff.data);

    if(at == 0) {
        // transpose
        jsfeat.matmath.transpose(a_mt, A);
    } else {
        for(i = 0; i &lt; _n*_m; i++) {
            a_mt.data[i] = A.data[i];
        }
        for(; i &lt; n*m; i++) {
            a_mt.data[i] = 0;
        }
    }

    JacobiSVDImpl(a_mt.data, m, w_mt.data, v_mt.data, n, m, n, m);

    if(W) {
        for(i=0; i &lt; n; i++) {
            W.data[i] = w_mt.data[i];
        }
        for(; i &lt; _n; i++) {
            W.data[i] = 0;
        }
    }

    if (at == 0) {
        if(U &amp;&amp; (options &amp; jsfeat.SVD_U_T)) {
            i = m*m;
            while(--i &gt;= 0) {
                U.data[i] = a_mt.data[i];
            }
        } else if(U) {
            jsfeat.matmath.transpose(U, a_mt);
        }

        if(V &amp;&amp; (options &amp; jsfeat.SVD_V_T)) {
            i = n*n;
            while(--i &gt;= 0) {
                V.data[i] = v_mt.data[i];
            }
        } else if(V) {
            jsfeat.matmath.transpose(V, v_mt);
        }
    } else {
        if(U &amp;&amp; (options &amp; jsfeat.SVD_U_T)) {
            i = n*n;
            while(--i &gt;= 0) {
                U.data[i] = v_mt.data[i];
            }
        } else if(U) {
            jsfeat.matmath.transpose(U, v_mt);
        }

        if(V &amp;&amp; (options &amp; jsfeat.SVD_V_T)) {
            i = m*m;
            while(--i &gt;= 0) {
                V.data[i] = a_mt.data[i];
            }
        } else if(V) {
            jsfeat.matmath.transpose(V, a_mt);
        }
    }

    jsfeat.cache.put_buffer(a_buff);
    jsfeat.cache.put_buffer(w_buff);
    jsfeat.cache.put_buffer(v_buff);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var u_mt = new jsfeat.matrix_t(nrows, nrows, dt, u_buff.data);
var w_mt = new jsfeat.matrix_t(1, ncols, dt, w_buff.data);
var v_mt = new jsfeat.matrix_t(ncols, ncols, dt, v_buff.data);

var bd = B.data, ud = u_mt.data, wd = w_mt.data, vd = v_mt.data;

this.<span class="apidocCodeKeywordSpan">svd_decompose</span>(A, w_mt, u_mt, v_mt, 0);

tol = jsfeat.EPSILON * wd[0] * ncols;

for (; i &lt; ncols; i++, pv += ncols) {
    xsum = 0.0;
    for(j = 0; j &lt; ncols; j++) {
        if(wd[j] &gt; tol) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.linalg.svd_invert" id="apidoc.element.jsfeat.linalg.svd_invert">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_invert
        <span class="apidocSignatureSpan">(Ai, A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">svd_invert = function (Ai, A) {
    var i=0,j=0,k=0;
    var pu=0,pv=0,pa=0;
    var nrows=A.rows,ncols=A.cols;
    var sum=0.0,tol=0.0;
    var dt = A.type | jsfeat.C1_t;

    var u_buff = jsfeat.cache.get_buffer((nrows*nrows)&lt;&lt;3);
    var w_buff = jsfeat.cache.get_buffer(ncols&lt;&lt;3);
    var v_buff = jsfeat.cache.get_buffer((ncols*ncols)&lt;&lt;3);

    var u_mt = new jsfeat.matrix_t(nrows, nrows, dt, u_buff.data);
    var w_mt = new jsfeat.matrix_t(1, ncols, dt, w_buff.data);
    var v_mt = new jsfeat.matrix_t(ncols, ncols, dt, v_buff.data);

    var id = Ai.data, ud = u_mt.data, wd = w_mt.data, vd = v_mt.data;

    this.svd_decompose(A, w_mt, u_mt, v_mt, 0);

    tol = jsfeat.EPSILON * wd[0] * ncols;

    for (; i &lt; ncols; i++, pv += ncols) {
        for (j = 0, pu = 0; j &lt; nrows; j++, pa++) {
            for (k = 0, sum = 0.0; k &lt; ncols; k++, pu++) {
                if (wd[k] &gt; tol) sum += vd[pv + k] * ud[pu] / wd[k];
            }
            id[pa] = sum;
        }
    }

    jsfeat.cache.put_buffer(u_buff);
    jsfeat.cache.put_buffer(w_buff);
    jsfeat.cache.put_buffer(v_buff);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.linalg.svd_solve" id="apidoc.element.jsfeat.linalg.svd_solve">
        function <span class="apidocSignatureSpan">jsfeat.linalg.</span>svd_solve
        <span class="apidocSignatureSpan">(A, X, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">svd_solve = function (A, X, B) {
    var i=0,j=0,k=0;
    var pu=0,pv=0;
    var nrows=A.rows,ncols=A.cols;
    var sum=0.0,xsum=0.0,tol=0.0;
    var dt = A.type | jsfeat.C1_t;

    var u_buff = jsfeat.cache.get_buffer((nrows*nrows)&lt;&lt;3);
    var w_buff = jsfeat.cache.get_buffer(ncols&lt;&lt;3);
    var v_buff = jsfeat.cache.get_buffer((ncols*ncols)&lt;&lt;3);

    var u_mt = new jsfeat.matrix_t(nrows, nrows, dt, u_buff.data);
    var w_mt = new jsfeat.matrix_t(1, ncols, dt, w_buff.data);
    var v_mt = new jsfeat.matrix_t(ncols, ncols, dt, v_buff.data);

    var bd = B.data, ud = u_mt.data, wd = w_mt.data, vd = v_mt.data;

    this.svd_decompose(A, w_mt, u_mt, v_mt, 0);

    tol = jsfeat.EPSILON * wd[0] * ncols;

    for (; i &lt; ncols; i++, pv += ncols) {
        xsum = 0.0;
        for(j = 0; j &lt; ncols; j++) {
            if(wd[j] &gt; tol) {
                for(k = 0, sum = 0.0, pu = 0; k &lt; nrows; k++, pu += ncols) {
                    sum += ud[pu + j] * bd[k];
                }
                xsum += sum * vd[pv + j] / wd[j];
            }
        }
        X.data[i] = xsum;
    }

    jsfeat.cache.put_buffer(u_buff);
    jsfeat.cache.put_buffer(w_buff);
    jsfeat.cache.put_buffer(v_buff);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.math" id="apidoc.module.jsfeat.math">module jsfeat.math</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.math.get_gaussian_kernel" id="apidoc.element.jsfeat.math.get_gaussian_kernel">
        function <span class="apidocSignatureSpan">jsfeat.math.</span>get_gaussian_kernel
        <span class="apidocSignatureSpan">(size, sigma, kernel, data_type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_gaussian_kernel = function (size, sigma, kernel, data_type) {
    var i=0,x=0.0,t=0.0,sigma_x=0.0,scale_2x=0.0;
    var sum = 0.0;
    var kern_node = jsfeat.cache.get_buffer(size&lt;&lt;2);
    var _kernel = kern_node.f32;//new Float32Array(size);

    if((size&amp;1) == 1 &amp;&amp; size &lt;= 7 &amp;&amp; sigma &lt;= 0) {
        switch(size&gt;&gt;1) {
            case 0:
            _kernel[0] = 1.0;
            sum = 1.0;
            break;
            case 1:
            _kernel[0] = 0.25, _kernel[1] = 0.5, _kernel[2] = 0.25;
            sum = 0.25+0.5+0.25;
            break;
            case 2:
            _kernel[0] = 0.0625, _kernel[1] = 0.25, _kernel[2] = 0.375,
            _kernel[3] = 0.25, _kernel[4] = 0.0625;
            sum = 0.0625+0.25+0.375+0.25+0.0625;
            break;
            case 3:
            _kernel[0] = 0.03125, _kernel[1] = 0.109375, _kernel[2] = 0.21875,
            _kernel[3] = 0.28125, _kernel[4] = 0.21875, _kernel[5] = 0.109375, _kernel[6] = 0.03125;
            sum = 0.03125+0.109375+0.21875+0.28125+0.21875+0.109375+0.03125;
            break;
        }
    } else {
        sigma_x = sigma &gt; 0 ? sigma : ((size-1)*0.5 - 1.0)*0.3 + 0.8;
        scale_2x = -0.5/(sigma_x*sigma_x);

        for( ; i &lt; size; ++i )
        {
            x = i - (size-1)*0.5;
            t = Math.exp(scale_2x*x*x);

            _kernel[i] = t;
            sum += t;
        }
    }

    if(data_type &amp; jsfeat.U8_t) {
        // int based kernel
        sum = 256.0/sum;
        for (i = 0; i &lt; size; ++i) {
            kernel[i] = (_kernel[i] * sum + 0.5)|0;
        }
    } else {
        // classic kernel
        sum = 1.0/sum;
        for (i = 0; i &lt; size; ++i) {
            kernel[i] = _kernel[i] * sum;
        }
    }

    jsfeat.cache.put_buffer(kern_node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    buf = buf_node.i32;
    filter = filt_node.f32;
} else {
    buf = buf_node.f32;
    filter = filt_node.f32;
}

jsfeat.math.<span class="apidocCodeKeywordSpan">get_gaussian_kernel</span>(kernel_size, sigma, filter, data_type);

if(is_u8) {
    _convol_u8(buf, src_d, dst_d, w, h, filter, kernel_size, half_kernel);
} else {
    _convol(buf, src_d, dst_d, w, h, filter, kernel_size, half_kernel);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.math.median" id="apidoc.element.jsfeat.math.median">
        function <span class="apidocSignatureSpan">jsfeat.math.</span>median
        <span class="apidocSignatureSpan">(array, low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">median = function (array, low, high) {
    var w;
    var middle=0,ll=0,hh=0,median=(low+high)&gt;&gt;1;
    for (;;) {
        if (high &lt;= low) return array[median];
        if (high == (low + 1)) {
            if (array[low] &gt; array[high]) {
                w = array[low];
                array[low] = array[high];
                array[high] = w;
            }
            return array[median];
        }
        middle = ((low + high) &gt;&gt; 1);
        if (array[middle] &gt; array[high]) {
            w = array[middle];
            array[middle] = array[high];
            array[high] = w;
        }
        if (array[low] &gt; array[high]) {
            w = array[low];
            array[low] = array[high];
            array[high] = w;
        }
        if (array[middle] &gt; array[low]) {
            w = array[middle];
            array[middle] = array[low];
            array[low] = w;
        }
        ll = (low + 1);
        w = array[middle];
        array[middle] = array[ll];
        array[ll] = w;
        hh = high;
        for (;;) {
            do ++ll; while (array[low] &gt; array[ll]);
            do --hh; while (array[hh] &gt; array[low]);
            if (hh &lt; ll) break;
            w = array[ll];
            array[ll] = array[hh];
            array[hh] = w;
        }
        w = array[low];
        array[low] = array[hh];
        array[hh] = w;
        if (hh &lt;= median)
            low = ll;
        else if (hh &gt;= median)
            high = (hh - 1);
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        nmodels = kernel.run( subset0, subset1, M, model_points );
			        if(nmodels &lt;= 0)
			            continue;

			        // TODO handle multimodel output

			        kernel.error(from, to, M, err, count);
			        median = jsfeat.math.<span class="apidocCodeKeywordSpan">median</span>(err, 0, count-1);

			        if(median &lt; min_median) {
			            min_median = median;
			            M.copy_to(model);
			            result = true;
			        }
			    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.math.perspective_4point_transform" id="apidoc.element.jsfeat.math.perspective_4point_transform">
        function <span class="apidocSignatureSpan">jsfeat.math.</span>perspective_4point_transform
        <span class="apidocSignatureSpan">(model, src_x0, src_y0, dst_x0, dst_y0, src_x1, src_y1, dst_x1, dst_y1, src_x2, src_y2, dst_x2, dst_y2, src_x3, src_y3, dst_x3, dst_y3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perspective_4point_transform = function (model, src_x0, src_y0, dst_x0, dst_y0, src_x1, src_y1, dst_x1, dst_y1, src_x2, src_y2, dst_x2, dst_y2, src_x3, src_y3, dst_x3, dst_y3) {
    var t1 = src_x0;
    var t2 = src_x2;
    var t4 = src_y1;
    var t5 = t1 * t2 * t4;
    var t6 = src_y3;
    var t7 = t1 * t6;
    var t8 = t2 * t7;
    var t9 = src_y2;
    var t10 = t1 * t9;
    var t11 = src_x1;
    var t14 = src_y0;
    var t15 = src_x3;
    var t16 = t14 * t15;
    var t18 = t16 * t11;
    var t20 = t15 * t11 * t9;
    var t21 = t15 * t4;
    var t24 = t15 * t9;
    var t25 = t2 * t4;
    var t26 = t6 * t2;
    var t27 = t6 * t11;
    var t28 = t9 * t11;
    var t30 = 1.0 / (t21-t24 - t25 + t26 - t27 + t28);
    var t32 = t1 * t15;
    var t35 = t14 * t11;
    var t41 = t4 * t1;
    var t42 = t6 * t41;
    var t43 = t14 * t2;
    var t46 = t16 * t9;
    var t48 = t14 * t9 * t11;
    var t51 = t4 * t6 * t2;
    var t55 = t6 * t14;
    var Hr0 = -(t8-t5 + t10 * t11 - t11 * t7 - t16 * t2 + t18 - t20 + t21 * t2) * t30;
    var Hr1 = (t5 - t8 - t32 * t4 + t32 * t9 + t18 - t2 * t35 + t27 * t2 - t20) * t30;
    var Hr2 = t1;
    var Hr3 = (-t9 * t7 + t42 + t43 * t4 - t16 * t4 + t46 - t48 + t27 * t9 - t51) * t30;
    var Hr4 = (-t42 + t41 * t9 - t55 * t2 + t46 - t48 + t55 * t11 + t51 - t21 * t9) * t30;
    var Hr5 = t14;
    var Hr6 = (-t10 + t41 + t43 - t35 + t24 - t21 - t26 + t27) * t30;
    var Hr7 = (-t7 + t10 + t16 - t43 + t27 - t28 - t21 + t25) * t30;

    t1 = dst_x0;
    t2 = dst_x2;
    t4 = dst_y1;
    t5 = t1 * t2 * t4;
    t6 = dst_y3;
    t7 = t1 * t6;
    t8 = t2 * t7;
    t9 = dst_y2;
    t10 = t1 * t9;
    t11 = dst_x1;
    t14 = dst_y0;
    t15 = dst_x3;
    t16 = t14 * t15;
    t18 = t16 * t11;
    t20 = t15 * t11 * t9;
    t21 = t15 * t4;
    t24 = t15 * t9;
    t25 = t2 * t4;
    t26 = t6 * t2;
    t27 = t6 * t11;
    t28 = t9 * t11;
    t30 = 1.0 / (t21-t24 - t25 + t26 - t27 + t28);
    t32 = t1 * t15;
    t35 = t14 * t11;
    t41 = t4 * t1;
    t42 = t6 * t41;
    t43 = t14 * t2;
    t46 = t16 * t9;
    t48 = t14 * t9 * t11;
    t51 = t4 * t6 * t2;
    t55 = t6 * t14;
    var Hl0 = -(t8-t5 + t10 * t11 - t11 * t7 - t16 * t2 + t18 - t20 + t21 * t2) * t30;
    var Hl1 = (t5 - t8 - t32 * t4 + t32 * t9 + t18 - t2 * t35 + t27 * t2 - t20) * t30;
    var Hl2 = t1;
    var Hl3 = (-t9 * t7 + t42 + t43 * t4 - t16 * t4 + t46 - t48 + t27 * t9 - t51) * t30;
    var Hl4 = (-t42 + t41 * t9 - t55 * t2 + t46 - t48 + t55 * t11 + t51 - t21 * t9) * t30;
    var Hl5 = t14;
    var Hl6 = (-t10 + t41 + t43 - t35 + t24 - t21 - t26 + t27) * t30;
    var Hl7 = (-t7 + t10 + t16 - t43 + t27 - t28 - t21 + t25) * t30;

    // the following code computes R = Hl * inverse Hr
    t2 = Hr4-Hr7*Hr5;
    t4 = Hr0*Hr4;
    t5 = Hr0*Hr5;
    t7 = Hr3*Hr1;
    t8 = Hr2*Hr3;
    t10 = Hr1*Hr6;
    var t12 = Hr2*Hr6;
    t15 = 1.0 / (t4-t5*Hr7-t7+t8*Hr7+t10*Hr5-t12*Hr4);
    t18 = -Hr3+Hr5*Hr6;
    var t23 = -Hr3*Hr7+Hr4*Hr6;
    t28 = -Hr1+Hr2*Hr7;
    var t31 = Hr0-t12;
    t35 = Hr0*Hr7-t10;
    t41 = -Hr1*Hr5+Hr2*Hr4;
    var t44 = t5-t8;
    var t47 = t4-t7;
    t48 = t2*t15;
    var t49 = t28*t15;
    var t50 = t41*t15;
    var mat = model.data;
    mat[0] = Hl0*t48+Hl1*(t18*t15)-Hl2*(t23*t15);
    mat[1] = Hl0*t49+Hl1*(t31*t15)-Hl2*(t35*t15);
    mat[2] = -Hl0*t50-Hl1*(t44*t15)+Hl2*(t47*t15);
    mat[3] = Hl3*t48+Hl4*(t18*t15)-Hl5*(t23*t15);
    mat[4] = Hl3*t49+Hl4*(t31*t15)-Hl5*(t35*t15);
    mat[5] = -Hl3*t50-Hl4*(t44*t15)+Hl5*(t47*t15);
    mat[6] = Hl6*t48+Hl7*(t18*t15)-t23*t15;
    mat[7] = Hl6*t49+Hl7*(t31*t15)-t35*t15;
    mat[8] = -Hl6*t50-Hl7*(t44*t15)+t47*t15;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.math.qsort" id="apidoc.element.jsfeat.math.qsort">
        function <span class="apidocSignatureSpan">jsfeat.math.</span>qsort
        <span class="apidocSignatureSpan">(array, low, high, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qsort = function (array, low, high, cmp) {
    var isort_thresh = 7;
    var t,ta,tb,tc;
    var sp = 0,left=0,right=0,i=0,n=0,m=0,ptr=0,ptr2=0,d=0;
    var left0=0,left1=0,right0=0,right1=0,pivot=0,a=0,b=0,c=0,swap_cnt=0;

    var stack = qsort_stack;

    if( (high-low+1) &lt;= 1 ) return;

    stack[0] = low;
    stack[1] = high;

    while( sp &gt;= 0 ) {

        left = stack[sp&lt;&lt;1];
        right = stack[(sp&lt;&lt;1)+1];
        sp--;

        for(;;) {
            n = (right - left) + 1;

            if( n &lt;= isort_thresh ) {
            //insert_sort:
                for( ptr = left + 1; ptr &lt;= right; ptr++ ) {
                    for( ptr2 = ptr; ptr2 &gt; left &amp;&amp; cmp(array[ptr2],array[ptr2-1]); ptr2--) {
                        t = array[ptr2];
                        array[ptr2] = array[ptr2-1];
                        array[ptr2-1] = t;
                    }
                }
                break;
            } else {
                swap_cnt = 0;

                left0 = left;
                right0 = right;
                pivot = left + (n&gt;&gt;1);

                if( n &gt; 40 ) {
                    d = n &gt;&gt; 3;
                    a = left, b = left + d, c = left + (d&lt;&lt;1);
                    ta = array[a],tb = array[b],tc = array[c];
                    left = cmp(ta, tb) ? (cmp(tb, tc) ? b : (cmp(ta, tc) ? c : a))
                                      : (cmp(tc, tb) ? b : (cmp(ta, tc) ? a : c));

                    a = pivot - d, b = pivot, c = pivot + d;
                    ta = array[a],tb = array[b],tc = array[c];
                    pivot = cmp(ta, tb) ? (cmp(tb, tc) ? b : (cmp(ta, tc) ? c : a))
                                      : (cmp(tc, tb) ? b : (cmp(ta, tc) ? a : c));

                    a = right - (d&lt;&lt;1), b = right - d, c = right;
                    ta = array[a],tb = array[b],tc = array[c];
                    right = cmp(ta, tb) ? (cmp(tb, tc) ? b : (cmp(ta, tc) ? c : a))
                                      : (cmp(tc, tb) ? b : (cmp(ta, tc) ? a : c));
                }

                a = left, b = pivot, c = right;
                ta = array[a],tb = array[b],tc = array[c];
                pivot = cmp(ta, tb) ? (cmp(tb, tc) ? b : (cmp(ta, tc) ? c : a))
                                   : (cmp(tc, tb) ? b : (cmp(ta, tc) ? a : c));
                if( pivot != left0 ) {
                    t = array[pivot];
                    array[pivot] = array[left0];
                    array[left0] = t;
                    pivot = left0;
                }
                left = left1 = left0 + 1;
                right = right1 = right0;

                ta = array[pivot];
                for(;;) {
                    while( left &lt;= right &amp;&amp; !cmp(ta, array[left]) ) {
                        if( !cmp(array[left], ta) ) {
                            if( left &gt; left1 ) {
                                t = array[left1];
                                array[left1] = array[left];
                                array[left] = t;
                            }
                            swap_cnt = 1;
                            left1++;
                        }
                        left++;
                    }

                    while( left &lt;= right &amp;&amp; !cmp(array[right], ta) ) {
                        if( !cmp(ta, array[right]) ) {
                            if( right &lt; right1 ) {
                                t = array[right1];
                                array[right1] = array[right];
                                array[right] = t;
                            }
                            swap_cnt = 1;
                            right1--;
                        }
                        right--;
                    }

                    if( left &gt; right ) break;

                    t = array[left];
                    array[left] = array[right];
                    array[right] = t;
                    swap_cnt = 1;
                    left++;
                    right--; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.matmath" id="apidoc.module.jsfeat.matmath">module jsfeat.matmath</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.matmath.determinant_3x3" id="apidoc.element.jsfeat.matmath.determinant_3x3">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>determinant_3x3
        <span class="apidocSignatureSpan">(M11, M12, M13, M21, M22, M23, M31, M32, M33)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">determinant_3x3 = function (M11, M12, M13, M21, M22, M23, M31, M32, M33) {
    return  M11 * M22 * M33 - M11 * M23 * M32 -
              M21 * M12 * M33 + M21 * M13 * M32 +
              M31 * M12 * M23 - M31 * M13 * M22;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        var A21=fp1.x, A22=fp1.y, A23=1.0;
			        var A31=fp2.x, A32=fp2.y, A33=1.0;

			        var B11=tp0.x, B12=tp0.y, B13=1.0;
			        var B21=tp1.x, B22=tp1.y, B23=1.0;
			        var B31=tp2.x, B32=tp2.y, B33=1.0;

			        var detA = jsfeat.matmath.<span class="apidocCodeKeywordSpan">determinant_3x3</span>(A11,A12,A13, A21,A22,A23, A31,A32
,A33);
					var detB = jsfeat.matmath.determinant_3x3(B11,B12,B13, B21,B22,B23, B31,B32,B33);

					if(detA*detB &lt; 0) negative++;

					// set2
					A11=fp1.x, A12=fp1.y;
			        A21=fp2.x, A22=fp2.y;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.identity" id="apidoc.element.jsfeat.matmath.identity">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>identity
        <span class="apidocSignatureSpan">(M, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (M, value) {
    if (typeof value === "undefined") { value=1; }
    var src=M.data;
    var rows=M.rows, cols=M.cols, cols_1=(cols+1)|0;
    var len = rows * cols;
    var k = len;
    while(--len &gt;= 0) src[len] = 0.0;
    len = k;
    k = 0;
    while(k &lt; len)  {
        src[k] = value;
        k = k + cols_1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.identity_3x3" id="apidoc.element.jsfeat.matmath.identity_3x3">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>identity_3x3
        <span class="apidocSignatureSpan">(M, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity_3x3 = function (M, value) {
    if (typeof value === "undefined") { value=1; }
    var dt=M.data;
    dt[0] = dt[4] = dt[8] = value;
    dt[1] = dt[2] = dt[3] = 0;
    dt[5] = dt[6] = dt[7] = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.invert_3x3" id="apidoc.element.jsfeat.matmath.invert_3x3">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>invert_3x3
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert_3x3 = function (from, to) {
    var A = from.data, invA = to.data;
    var t1 = A[4];
    var t2 = A[8];
    var t4 = A[5];
    var t5 = A[7];
    var t8 = A[0];

    var t9 = t8*t1;
    var t11 = t8*t4;
    var t13 = A[3];
    var t14 = A[1];
    var t15 = t13*t14;
    var t17 = A[2];
    var t18 = t13*t17;
    var t20 = A[6];
    var t21 = t20*t14;
    var t23 = t20*t17;
    var t26 = 1.0/(t9*t2-t11*t5-t15*t2+t18*t5+t21*t4-t23*t1);
    invA[0] = (t1*t2-t4*t5)*t26;
    invA[1] = -(t14*t2-t17*t5)*t26;
    invA[2] = -(-t14*t4+t17*t1)*t26;
    invA[3] = -(t13*t2-t4*t20)*t26;
    invA[4] = (t8*t2-t23)*t26;
    invA[5] = -(t11-t18)*t26;
    invA[6] = -(-t13*t5+t1*t20)*t26;
    invA[7] = -(t8*t5-t21)*t26;
    invA[8] = (t9-t15)*t26;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			    jsfeat.linalg.lu_solve(AtA, AtB);

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row

			    // denormalize
			    jsfeat.matmath.<span class="apidocCodeKeywordSpan">invert_3x3</span>(T1, T1);
			    jsfeat.matmath.multiply_3x3(model, T1, model);
			    jsfeat.matmath.multiply_3x3(model, model, T0);

			    // free buffer
			    jsfeat.cache.put_buffer(a_buff);
			    jsfeat.cache.put_buffer(b_buff);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.mat3x3_determinant" id="apidoc.element.jsfeat.matmath.mat3x3_determinant">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>mat3x3_determinant
        <span class="apidocSignatureSpan">(M)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mat3x3_determinant = function (M) {
    var md=M.data;
    return  md[0] * md[4] * md[8] -
            md[0] * md[5] * md[7] -
            md[3] * md[1] * md[8] +
            md[3] * md[2] * md[7] +
            md[6] * md[1] * md[5] -
            md[6] * md[2] * md[4];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply" id="apidoc.element.jsfeat.matmath.multiply">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply
        <span class="apidocSignatureSpan">(C, A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (C, A, B) {
    var i=0,j=0,k=0;
    var Ap=0,pA=0,pB=0,p_B=0,Cp=0;
    var ncols=A.cols,nrows=A.rows,mcols=B.cols;
    var ad=A.data,bd=B.data,cd=C.data;
    var sum=0.0;

    for (; i &lt; nrows; Ap += ncols, i++) {
        for (p_B = 0, j = 0; j &lt; mcols; Cp++, p_B++, j++) {
            pB = p_B;
            pA = Ap;
            sum = 0.0;
            for (k = 0; k &lt; ncols; pA++, pB += mcols, k++) {
                sum += ad[pA] * bd[pB];
            }
            cd[Cp] = sum;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply_3x3" id="apidoc.element.jsfeat.matmath.multiply_3x3">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_3x3
        <span class="apidocSignatureSpan">(C, A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply_3x3 = function (C, A, B) {
    var Cd=C.data, Ad=A.data, Bd=B.data;
    var m1_0 = Ad[0], m1_1 = Ad[1], m1_2 = Ad[2];
    var m1_3 = Ad[3], m1_4 = Ad[4], m1_5 = Ad[5];
    var m1_6 = Ad[6], m1_7 = Ad[7], m1_8 = Ad[8];

    var m2_0 = Bd[0], m2_1 = Bd[1], m2_2 = Bd[2];
    var m2_3 = Bd[3], m2_4 = Bd[4], m2_5 = Bd[5];
    var m2_6 = Bd[6], m2_7 = Bd[7], m2_8 = Bd[8];

    Cd[0] = m1_0 * m2_0 + m1_1 * m2_3 + m1_2 * m2_6;
    Cd[1] = m1_0 * m2_1 + m1_1 * m2_4 + m1_2 * m2_7;
    Cd[2] = m1_0 * m2_2 + m1_1 * m2_5 + m1_2 * m2_8;
    Cd[3] = m1_3 * m2_0 + m1_4 * m2_3 + m1_5 * m2_6;
    Cd[4] = m1_3 * m2_1 + m1_4 * m2_4 + m1_5 * m2_7;
    Cd[5] = m1_3 * m2_2 + m1_4 * m2_5 + m1_5 * m2_8;
    Cd[6] = m1_6 * m2_0 + m1_7 * m2_3 + m1_8 * m2_6;
    Cd[7] = m1_6 * m2_1 + m1_7 * m2_4 + m1_8 * m2_7;
    Cd[8] = m1_6 * m2_2 + m1_7 * m2_5 + m1_8 * m2_8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row

			    // denormalize
			    jsfeat.matmath.invert_3x3(T1, T1);
			    jsfeat.matmath.<span class="apidocCodeKeywordSpan">multiply_3x3</span>(model, T1, model);
			    jsfeat.matmath.multiply_3x3(model, model, T0);

			    // free buffer
			    jsfeat.cache.put_buffer(a_buff);
			    jsfeat.cache.put_buffer(b_buff);

			    return 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply_AAt" id="apidoc.element.jsfeat.matmath.multiply_AAt">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AAt
        <span class="apidocSignatureSpan">(C, A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply_AAt = function (C, A) {
    var i=0,j=0,k=0;
    var pCdiag=0,p_A=0,pA=0,pB=0,pC=0,pCt=0;
    var ncols=A.cols,nrows=A.rows;
    var ad=A.data,cd=C.data;
    var sum=0.0;

    for (; i &lt; nrows; pCdiag += nrows + 1, p_A = pA, i++) {
        pC = pCdiag;
        pCt = pCdiag;
        pB = p_A;
        for (j = i; j &lt; nrows; pC++, pCt += nrows, j++) {
            pA = p_A;
            sum = 0.0;
            for (k = 0; k &lt; ncols; k++) {
                sum += ad[pA++] * ad[pB++];
            }
            cd[pC] = sum
            cd[pCt] = sum;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply_ABt" id="apidoc.element.jsfeat.matmath.multiply_ABt">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_ABt
        <span class="apidocSignatureSpan">(C, A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply_ABt = function (C, A, B) {
    var i=0,j=0,k=0;
    var Ap=0,pA=0,pB=0,Cp=0;
    var ncols=A.cols,nrows=A.rows,mrows=B.rows;
    var ad=A.data,bd=B.data,cd=C.data;
    var sum=0.0;

    for (; i &lt; nrows; Ap += ncols, i++) {
        for (pB = 0, j = 0; j &lt; mrows; Cp++, j++) {
            pA = Ap;
            sum = 0.0;
            for (k = 0; k &lt; ncols; pA++, pB++, k++) {
                sum += ad[pA] * bd[pB];
            }
            cd[Cp] = sum;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply_AtA" id="apidoc.element.jsfeat.matmath.multiply_AtA">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AtA
        <span class="apidocSignatureSpan">(C, A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply_AtA = function (C, A) {
    var i=0,j=0,k=0;
    var p_A=0,pA=0,pB=0,p_C=0,pC=0,p_CC=0;
    var ncols=A.cols,nrows=A.rows;
    var ad=A.data,cd=C.data;
    var sum=0.0;

    for (; i &lt; ncols; p_C += ncols, i++) {
        p_A = i;
        p_CC = p_C + i;
        pC = p_CC;
        for (j = i; j &lt; ncols; pC++, p_CC += ncols, j++) {
            pA = p_A;
            pB = j;
            sum = 0.0;
            for (k = 0; k &lt; nrows; pA += ncols, pB += ncols, k++) {
                sum += ad[pA] * ad[pB];
            }
            cd[pC] = sum
            cd[p_CC] = sum;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        j += 6;
			        ad[j]=0.0, ad[j+1]=0.0, ad[j+2]=0.0, ad[j+3]=px, ad[j+4]=py, ad[j+5]=1.0;

			        bd[i&lt;&lt;1] = t1d[0]*pt1.x + t1d[1]*pt1.y + t1d[2];
			        bd[(i&lt;&lt;1)+1] = t1d[3]*pt1.x + t1d[4]*pt1.y + t1d[5];
			    }

			    jsfeat.matmath.<span class="apidocCodeKeywordSpan">multiply_AtA</span>(AtA, a_mt);
			    jsfeat.matmath.multiply_AtB(AtB, a_mt, b_mt);

			    jsfeat.linalg.lu_solve(AtA, AtB);

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.multiply_AtB" id="apidoc.element.jsfeat.matmath.multiply_AtB">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>multiply_AtB
        <span class="apidocSignatureSpan">(C, A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply_AtB = function (C, A, B) {
    var i=0,j=0,k=0;
    var Ap=0,pA=0,pB=0,p_B=0,Cp=0;
    var ncols=A.cols,nrows=A.rows,mcols=B.cols;
    var ad=A.data,bd=B.data,cd=C.data;
    var sum=0.0;

    for (; i &lt; ncols; Ap++, i++) {
        for (p_B = 0, j = 0; j &lt; mcols; Cp++, p_B++, j++) {
            pB = p_B;
            pA = Ap;
            sum = 0.0;
            for (k = 0; k &lt; nrows; pA += ncols, pB += mcols, k++) {
                sum += ad[pA] * bd[pB];
            }
            cd[Cp] = sum;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        ad[j]=0.0, ad[j+1]=0.0, ad[j+2]=0.0, ad[j+3]=px, ad[j+4]=py, ad[j+5]=1.0;

			        bd[i&lt;&lt;1] = t1d[0]*pt1.x + t1d[1]*pt1.y + t1d[2];
			        bd[(i&lt;&lt;1)+1] = t1d[3]*pt1.x + t1d[4]*pt1.y + t1d[5];
			    }

			    jsfeat.matmath.multiply_AtA(AtA, a_mt);
			    jsfeat.matmath.<span class="apidocCodeKeywordSpan">multiply_AtB</span>(AtB, a_mt, b_mt);

			    jsfeat.linalg.lu_solve(AtA, AtB);

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matmath.transpose" id="apidoc.element.jsfeat.matmath.transpose">
        function <span class="apidocSignatureSpan">jsfeat.matmath.</span>transpose
        <span class="apidocSignatureSpan">(At, A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (At, A) {
    var i=0,j=0,nrows=A.rows,ncols=A.cols;
    var Ai=0,Ati=0,pAt=0;
    var ad=A.data,atd=At.data;

    for (; i &lt; nrows; Ati += 1, Ai += ncols, i++) {
        pAt = Ati;
        for (j = 0; j &lt; ncols; pAt += nrows, j++) atd[pAt] = ad[Ai+j];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var a_mt = new jsfeat.matrix_t(m, m, dt, a_buff.data);
var w_mt = new jsfeat.matrix_t(1, n, dt, w_buff.data);
var v_mt = new jsfeat.matrix_t(n, n, dt, v_buff.data);

if(at == 0) {
    // transpose
    jsfeat.matmath.<span class="apidocCodeKeywordSpan">transpose</span>(a_mt, A);
} else {
    for(i = 0; i &lt; _n*_m; i++) {
        a_mt.data[i] = A.data[i];
    }
    for(; i &lt; n*m; i++) {
        a_mt.data[i] = 0;
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.matrix_t" id="apidoc.module.jsfeat.matrix_t">module jsfeat.matrix_t</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.matrix_t.matrix_t" id="apidoc.element.jsfeat.matrix_t.matrix_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>matrix_t
        <span class="apidocSignatureSpan">(c, r, data_type, data_buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matrix_t(c, r, data_type, data_buffer) {
    this.type = get_data_type(data_type)|0;
    this.channel = get_channel(data_type)|0;
    this.cols = c|0;
    this.rows = r|0;
    if (typeof data_buffer === "undefined") {
        this.allocate();
    } else {
        this.buffer = data_buffer;
        // data user asked for
        this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this.buffer.f32 :
this.buffer.f64));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    n = i;
}

var a_buff = jsfeat.cache.get_buffer((m*m)&lt;&lt;3);
var w_buff = jsfeat.cache.get_buffer(n&lt;&lt;3);
var v_buff = jsfeat.cache.get_buffer((n*n)&lt;&lt;3);

var a_mt = new jsfeat.<span class="apidocCodeKeywordSpan">matrix_t</span>(m, m, dt, a_buff.data);
var w_mt = new jsfeat.matrix_t(1, n, dt, w_buff.data);
var v_mt = new jsfeat.matrix_t(n, n, dt, v_buff.data);

if(at == 0) {
    // transpose
    jsfeat.matmath.transpose(a_mt, A);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.matrix_t.prototype" id="apidoc.module.jsfeat.matrix_t.prototype">module jsfeat.matrix_t.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.matrix_t.prototype.allocate" id="apidoc.element.jsfeat.matrix_t.prototype.allocate">
        function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>allocate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocate = function () {
    // clear references
    delete this.data;
    delete this.buffer;
    //
    this.buffer = new data_t((this.cols * get_data_type_size(this.type) * this.channel) * this.rows);
    this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this.buffer.f32 : this
.buffer.f64));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// columns, rows, data_type
function matrix_t(c, r, data_type, data_buffer) {
    this.type = get_data_type(data_type)|0;
    this.channel = get_channel(data_type)|0;
    this.cols = c|0;
    this.rows = r|0;
    if (typeof data_buffer === "undefined") {
        this.<span class="apidocCodeKeywordSpan">allocate</span>();
    } else {
        this.buffer = data_buffer;
        // data user asked for
        this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this
.buffer.f32 : this.buffer.f64));
    }
}
matrix_t.prototype.allocate = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matrix_t.prototype.copy_to" id="apidoc.element.jsfeat.matrix_t.prototype.copy_to">
        function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>copy_to
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy_to = function (other) {
    var od = other.data, td = this.data;
    var i = 0, n = (this.cols*this.rows*this.channel)|0;
    for(; i &lt; n-4; i+=4) {
        od[i] = td[i];
        od[i+1] = td[i+1];
        od[i+2] = td[i+2];
        od[i+3] = td[i+3];
    }
    for(; i &lt; n; ++i) {
        od[i] = td[i];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			        if(kernel.run(from, to, M, count) &lt;= 0) {
			        	jsfeat.cache.put_buffer(m_buff);
			        	jsfeat.cache.put_buffer(ms_buff);
			        	jsfeat.cache.put_buffer(err_buff);
			        	return false;
			        }

			        M.<span class="apidocCodeKeywordSpan">copy_to</span>(model);
			        if(mask) {
			        	while(--count &gt;= 0) {
			        		mask.data[count] = 1;
			        	}
			        }
			        jsfeat.cache.put_buffer(m_buff);
			        jsfeat.cache.put_buffer(ms_buff);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.matrix_t.prototype.resize" id="apidoc.element.jsfeat.matrix_t.prototype.resize">
        function <span class="apidocSignatureSpan">jsfeat.matrix_t.prototype.</span>resize
        <span class="apidocSignatureSpan">(c, r, ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (c, r, ch) {
    if (typeof ch === "undefined") { ch = this.channel; }
    // relocate buffer only if new size doesnt fit
    var new_size = (c * get_data_type_size(this.type) * ch) * r;
    if(new_size &gt; this.buffer.size) {
        this.cols = c;
        this.rows = r;
        this.channel = ch;
        this.allocate();
    } else {
        this.cols = c;
        this.rows = r;
        this.channel = ch;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
get_buffer: function(size_in_bytes) {
    // assume we have enough free nodes
    var node = _pool_head;
    _pool_head = _pool_head.next;
    _pool_size--;

    if(size_in_bytes &gt; node.size) {
        node.<span class="apidocCodeKeywordSpan">resize</span>(size_in_bytes);
    }

    return node;
},

put_buffer: function(node) {
    _pool_tail = _pool_tail.next = node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_estimator" id="apidoc.module.jsfeat.motion_estimator">module jsfeat.motion_estimator</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_estimator.lmeds" id="apidoc.element.jsfeat.motion_estimator.lmeds">
        function <span class="apidocSignatureSpan">jsfeat.motion_estimator.</span>lmeds
        <span class="apidocSignatureSpan">(params, kernel, from, to, count, model, mask, max_iters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lmeds = function (params, kernel, from, to, count, model, mask, max_iters) {
			if (typeof max_iters === "undefined") { max_iters=1000; }

			if(count &lt; params.size) return false;

			var model_points = params.size;
			    var niters = max_iters, iter=0;
			    var result = false;

			    var subset0 = [];
			    var subset1 = [];
			    var found = false;

			    var mc=model.cols,mr=model.rows;
            var dt = model.type | jsfeat.C1_t;

			    var m_buff = jsfeat.cache.get_buffer((mc*mr)&lt;&lt;3);
			    var ms_buff = jsfeat.cache.get_buffer(count);
			    var err_buff = jsfeat.cache.get_buffer(count&lt;&lt;2);
			    var M = new jsfeat.matrix_t(mc, mr, dt, m_buff.data);
			    var curr_mask = new jsfeat.matrix_t(count, 1, jsfeat.U8_t|jsfeat.C1_t, ms_buff.data);

			    var numinliers=0;
			    var nmodels = 0;

			    var err = err_buff.f32;
			    var min_median = 1000000000.0, sigma=0.0, median=0.0;

			    params.eps = 0.45;
			    niters = params.update_iters(params.eps, niters);

			    // special case
			    if(count == model_points) {
			        if(kernel.run(from, to, M, count) &lt;= 0) {
			        	jsfeat.cache.put_buffer(m_buff);
			        	jsfeat.cache.put_buffer(ms_buff);
			        	jsfeat.cache.put_buffer(err_buff);
			        	return false;
			        }

			        M.copy_to(model);
			        if(mask) {
			        	while(--count &gt;= 0) {
			        		mask.data[count] = 1;
			        	}
			        }
			        jsfeat.cache.put_buffer(m_buff);
			        jsfeat.cache.put_buffer(ms_buff);
			        jsfeat.cache.put_buffer(err_buff);
			        return true;
			    }

			    for (; iter &lt; niters; ++iter) {
			        // generate subset
			        found = get_subset(kernel, from, to, model_points, count, subset0, subset1);
			        if(!found) {
			            if(iter == 0) {
			            	jsfeat.cache.put_buffer(m_buff);
			            	jsfeat.cache.put_buffer(ms_buff);
			            	jsfeat.cache.put_buffer(err_buff);
			                return false;
			            }
			            break;
			        }

			        nmodels = kernel.run( subset0, subset1, M, model_points );
			        if(nmodels &lt;= 0)
			            continue;

			        // TODO handle multimodel output

			        kernel.error(from, to, M, err, count);
			        median = jsfeat.math.median(err, 0, count-1);

			        if(median &lt; min_median) {
			            min_median = median;
			            M.copy_to(model);
			            result = true;
			        }
			    }

			    if(result) {
			        sigma = 2.5*1.4826*(1 + 5.0/(count - model_points))*Math.sqrt(min_median);
			        sigma = Math.max(sigma, 0.001);

			        numinliers = find_inliers(kernel, model, from, to, count, sigma, err, curr_mask.data);
			        if(mask) curr_mask.copy_to(mask);
			
			        result = numinliers &gt;= model_points;
			    }

			    jsfeat.cache.put_buffer(m_buff);
			    jsfeat.cache.put_buffer(ms_buff);
			    jsfeat.cache.put_buffer(err_buff);

			    return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_estimator.ransac" id="apidoc.element.jsfeat.motion_estimator.ransac">
        function <span class="apidocSignatureSpan">jsfeat.motion_estimator.</span>ransac
        <span class="apidocSignatureSpan">(params, kernel, from, to, count, model, mask, max_iters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ransac = function (params, kernel, from, to, count, model, mask, max_iters) {
			if (typeof max_iters === "undefined") { max_iters=1000; }

			if(count &lt; params.size) return false;

			var model_points = params.size;
			    var niters = max_iters, iter=0;
			    var result = false;

			    var subset0 = [];
			    var subset1 = [];
			    var found = false;

			    var mc=model.cols,mr=model.rows;
            var dt = model.type | jsfeat.C1_t;

			    var m_buff = jsfeat.cache.get_buffer((mc*mr)&lt;&lt;3);
			    var ms_buff = jsfeat.cache.get_buffer(count);
			    var err_buff = jsfeat.cache.get_buffer(count&lt;&lt;2);
			    var M = new jsfeat.matrix_t(mc, mr, dt, m_buff.data);
			    var curr_mask = new jsfeat.matrix_t(count, 1, jsfeat.U8C1_t, ms_buff.data);

			    var inliers_max = -1, numinliers=0;
			    var nmodels = 0;

			    var err = err_buff.f32;

			    // special case
			    if(count == model_points) {
			        if(kernel.run(from, to, M, count) &lt;= 0) {
			        	jsfeat.cache.put_buffer(m_buff);
			        	jsfeat.cache.put_buffer(ms_buff);
			        	jsfeat.cache.put_buffer(err_buff);
			        	return false;
			        }

			        M.copy_to(model);
			        if(mask) {
			        	while(--count &gt;= 0) {
			        		mask.data[count] = 1;
			        	}
			        }
			        jsfeat.cache.put_buffer(m_buff);
			        jsfeat.cache.put_buffer(ms_buff);
			        jsfeat.cache.put_buffer(err_buff);
			        return true;
			    }

			    for (; iter &lt; niters; ++iter) {
			        // generate subset
			        found = get_subset(kernel, from, to, model_points, count, subset0, subset1);
			        if(!found) {
			            if(iter == 0) {
			            	jsfeat.cache.put_buffer(m_buff);
			            	jsfeat.cache.put_buffer(ms_buff);
			            	jsfeat.cache.put_buffer(err_buff);
			                return false;
			            }
			            break;
			        }

			        nmodels = kernel.run( subset0, subset1, M, model_points );
			        if(nmodels &lt;= 0)
			            continue;

			        // TODO handle multimodel output

			        numinliers = find_inliers(kernel, M, from, to, count, params.thresh, err, curr_mask.data);

			        if( numinliers &gt; Math.max(inliers_max, model_points-1) ) {
			            M.copy_to(model);
			            inliers_max = numinliers;
			            if(mask) curr_mask.copy_to(mask);
			            niters = params.update_iters((count - numinliers)/count, niters);
			            result = true;
			        }
			    }

			    jsfeat.cache.put_buffer(m_buff);
			    jsfeat.cache.put_buffer(ms_buff);
			    jsfeat.cache.put_buffer(err_buff);

			    return result;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_model" id="apidoc.module.jsfeat.motion_model">module jsfeat.motion_model</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d" id="apidoc.element.jsfeat.motion_model.affine2d">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>affine2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function affine2d() {
	        	// empty constructor
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d" id="apidoc.element.jsfeat.motion_model.homography2d">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>homography2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function homography2d() {
	        	// empty constructor
	        	//this.T0 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.T1 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.mLtL = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.Evec = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_model.affine2d" id="apidoc.module.jsfeat.motion_model.affine2d">module jsfeat.motion_model.affine2d</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d.affine2d" id="apidoc.element.jsfeat.motion_model.affine2d.affine2d">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>affine2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function affine2d() {
	        	// empty constructor
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_model.affine2d.prototype" id="apidoc.module.jsfeat.motion_model.affine2d.prototype">module jsfeat.motion_model.affine2d.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.check_subset" id="apidoc.element.jsfeat.motion_model.affine2d.prototype.check_subset">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>check_subset
        <span class="apidocSignatureSpan">(from, to, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_subset = function (from, to, count) {
	            return true; // all good
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		                for (j = 0; j &lt; i; ++j) {
		                    if (idx_i == indices[j])
		                    { ok = false; break; }
		                }
		            }
		            from_sub[i] = from[idx_i];
		            to_sub[i] = to[idx_i];
		            if( !kernel.<span class="apidocCodeKeywordSpan">check_subset</span>( from_sub, to_sub, i+1 ) ) {
		                ssiter++;
		                continue;
		            }
		            ++i;
		        }
		        break;
		    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.error" id="apidoc.element.jsfeat.motion_model.affine2d.prototype.error">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>error
        <span class="apidocSignatureSpan">(from, to, model, err, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (from, to, model, err, count) {
	        	var i=0;
	        	var pt0,pt1;
	        	var m=model.data;

			    for (; i &lt; count; ++i) {
			        pt0 = from[i];
			        pt1 = to[i];

			        err[i] = sqr(pt1.x - m[0]*pt0.x - m[1]*pt0.y - m[2]) +
			                 sqr(pt1.y - m[3]*pt0.x - m[4]*pt0.y - m[5]);
			    }
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		    return (i == need_cnt &amp;&amp; ssiter &lt; max_try);
    	}

    	var find_inliers = function(kernel, model, from, to, count, thresh, err, mask) {
    		var numinliers = 0, i=0, f=0;
    		var t = thresh*thresh;

    		kernel.<span class="apidocCodeKeywordSpan">error</span>(from, to, model, err, count);

		    for(; i &lt; count; ++i) {
		        f = err[i] &lt;= t;
		        mask[i] = f;
		        numinliers += f;
		    }
		    return numinliers;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.affine2d.prototype.run" id="apidoc.element.jsfeat.motion_model.affine2d.prototype.run">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.affine2d.prototype.</span>run
        <span class="apidocSignatureSpan">(from, to, model, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (from, to, model, count) {
	        	var i=0,j=0;
	        	var dt=model.type|jsfeat.C1_t;
	        	var md=model.data, t0d=T0.data, t1d=T1.data;
	        	var pt0,pt1,px=0.0,py=0.0;

	            iso_normalize_points(from, to, t0d, t1d, count);

	            var a_buff = jsfeat.cache.get_buffer((2*count*6)&lt;&lt;3);
                var b_buff = jsfeat.cache.get_buffer((2*count)&lt;&lt;3);

                var a_mt = new jsfeat.matrix_t(6, 2*count, dt, a_buff.data);
                var b_mt = new jsfeat.matrix_t(1, 2*count, dt, b_buff.data);
                var ad=a_mt.data, bd=b_mt.data;

			    for (; i &lt; count; ++i) {
			    	pt0 = from[i];
			        pt1 = to[i];

			        px = t0d[0]*pt0.x + t0d[1]*pt0.y + t0d[2];
			        py = t0d[3]*pt0.x + t0d[4]*pt0.y + t0d[5];

			        j = i*2*6;
			        ad[j]=px, ad[j+1]=py, ad[j+2]=1.0, ad[j+3]=0.0, ad[j+4]=0.0, ad[j+5]=0.0;

			        j += 6;
			        ad[j]=0.0, ad[j+1]=0.0, ad[j+2]=0.0, ad[j+3]=px, ad[j+4]=py, ad[j+5]=1.0;

			        bd[i&lt;&lt;1] = t1d[0]*pt1.x + t1d[1]*pt1.y + t1d[2];
			        bd[(i&lt;&lt;1)+1] = t1d[3]*pt1.x + t1d[4]*pt1.y + t1d[5];
			    }

			    jsfeat.matmath.multiply_AtA(AtA, a_mt);
			    jsfeat.matmath.multiply_AtB(AtB, a_mt, b_mt);

			    jsfeat.linalg.lu_solve(AtA, AtB);

			    md[0] = AtB.data[0], md[1]=AtB.data[1], md[2]=AtB.data[2];
			    md[3] = AtB.data[3], md[4]=AtB.data[4], md[5]=AtB.data[5];
			    md[6] = 0.0, md[7] = 0.0, md[8] = 1.0; // fill last row

			    // denormalize
			    jsfeat.matmath.invert_3x3(T1, T1);
			    jsfeat.matmath.multiply_3x3(model, T1, model);
			    jsfeat.matmath.multiply_3x3(model, model, T0);

			    // free buffer
			    jsfeat.cache.put_buffer(a_buff);
			    jsfeat.cache.put_buffer(b_buff);

			    return 1;
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			    var inliers_max = -1, numinliers=0;
			    var nmodels = 0;

			    var err = err_buff.f32;

			    // special case
			    if(count == model_points) {
			        if(kernel.<span class="apidocCodeKeywordSpan">run</span>(from, to, M, count) &lt;= 0) {
			        	jsfeat.cache.put_buffer(m_buff);
			        	jsfeat.cache.put_buffer(ms_buff);
			        	jsfeat.cache.put_buffer(err_buff);
			        	return false;
			        }

			        M.copy_to(model);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_model.homography2d" id="apidoc.module.jsfeat.motion_model.homography2d">module jsfeat.motion_model.homography2d</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d.homography2d" id="apidoc.element.jsfeat.motion_model.homography2d.homography2d">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.</span>homography2d
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function homography2d() {
	        	// empty constructor
	        	//this.T0 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.T1 = new jsfeat.matrix_t(3, 3, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.mLtL = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        	//this.Evec = new jsfeat.matrix_t(9, 9, jsfeat.F32_t|jsfeat.C1_t);
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.motion_model.homography2d.prototype" id="apidoc.module.jsfeat.motion_model.homography2d.prototype">module jsfeat.motion_model.homography2d.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.check_subset" id="apidoc.element.jsfeat.motion_model.homography2d.prototype.check_subset">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>check_subset
        <span class="apidocSignatureSpan">(from, to, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check_subset = function (from, to, count) {
	        	// seems to reject good subsets actually
	        	//if( have_collinear_points(from, count) || have_collinear_points(to, count) ) {
        			//return false;
        		//}
        		if( count == 4 ) {
			        var negative = 0;

			        var fp0=from[0],fp1=from[1],fp2=from[2],fp3=from[3];
			        var tp0=to[0],tp1=to[1],tp2=to[2],tp3=to[3];

			        // set1
			        var A11=fp0.x, A12=fp0.y, A13=1.0;
			        var A21=fp1.x, A22=fp1.y, A23=1.0;
			        var A31=fp2.x, A32=fp2.y, A33=1.0;

			        var B11=tp0.x, B12=tp0.y, B13=1.0;
			        var B21=tp1.x, B22=tp1.y, B23=1.0;
			        var B31=tp2.x, B32=tp2.y, B33=1.0;

			        var detA = jsfeat.matmath.determinant_3x3(A11,A12,A13, A21,A22,A23, A31,A32,A33);
					var detB = jsfeat.matmath.determinant_3x3(B11,B12,B13, B21,B22,B23, B31,B32,B33);

					if(detA*detB &lt; 0) negative++;

					// set2
					A11=fp1.x, A12=fp1.y;
			        A21=fp2.x, A22=fp2.y;
			        A31=fp3.x, A32=fp3.y;

			        B11=tp1.x, B12=tp1.y;
			        B21=tp2.x, B22=tp2.y;
			        B31=tp3.x, B32=tp3.y;

			        detA = jsfeat.matmath.determinant_3x3(A11,A12,A13, A21,A22,A23, A31,A32,A33);
					detB = jsfeat.matmath.determinant_3x3(B11,B12,B13, B21,B22,B23, B31,B32,B33);

					if(detA*detB &lt; 0) negative++;

					// set3
					A11=fp0.x, A12=fp0.y;
			        A21=fp2.x, A22=fp2.y;
			        A31=fp3.x, A32=fp3.y;

			        B11=tp0.x, B12=tp0.y;
			        B21=tp2.x, B22=tp2.y;
			        B31=tp3.x, B32=tp3.y;

			        detA = jsfeat.matmath.determinant_3x3(A11,A12,A13, A21,A22,A23, A31,A32,A33);
					detB = jsfeat.matmath.determinant_3x3(B11,B12,B13, B21,B22,B23, B31,B32,B33);

					if(detA*detB &lt; 0) negative++;

					// set4
					A11=fp0.x, A12=fp0.y;
			        A21=fp1.x, A22=fp1.y;
			        A31=fp3.x, A32=fp3.y;

			        B11=tp0.x, B12=tp0.y;
			        B21=tp1.x, B22=tp1.y;
			        B31=tp3.x, B32=tp3.y;

			        detA = jsfeat.matmath.determinant_3x3(A11,A12,A13, A21,A22,A23, A31,A32,A33);
					detB = jsfeat.matmath.determinant_3x3(B11,B12,B13, B21,B22,B23, B31,B32,B33);

					if(detA*detB &lt; 0) negative++;

			        if(negative != 0 &amp;&amp; negative != 4) {
			        	return false;
			        }
			    }
	            return true; // all good
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		                for (j = 0; j &lt; i; ++j) {
		                    if (idx_i == indices[j])
		                    { ok = false; break; }
		                }
		            }
		            from_sub[i] = from[idx_i];
		            to_sub[i] = to[idx_i];
		            if( !kernel.<span class="apidocCodeKeywordSpan">check_subset</span>( from_sub, to_sub, i+1 ) ) {
		                ssiter++;
		                continue;
		            }
		            ++i;
		        }
		        break;
		    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.error" id="apidoc.element.jsfeat.motion_model.homography2d.prototype.error">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>error
        <span class="apidocSignatureSpan">(from, to, model, err, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (from, to, model, err, count) {
	        	var i=0;
	        	var pt0,pt1,ww=0.0,dx=0.0,dy=0.0;
	        	var m=model.data;

			    for (; i &lt; count; ++i) {
			        pt0 = from[i];
			        pt1 = to[i];

			        ww = 1.0/(m[6]*pt0.x + m[7]*pt0.y + 1.0);
			        dx = (m[0]*pt0.x + m[1]*pt0.y + m[2])*ww - pt1.x;
			        dy = (m[3]*pt0.x + m[4]*pt0.y + m[5])*ww - pt1.y;
			        err[i] = (dx*dx + dy*dy);
			    }
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		    return (i == need_cnt &amp;&amp; ssiter &lt; max_try);
    	}

    	var find_inliers = function(kernel, model, from, to, count, thresh, err, mask) {
    		var numinliers = 0, i=0, f=0;
    		var t = thresh*thresh;

    		kernel.<span class="apidocCodeKeywordSpan">error</span>(from, to, model, err, count);

		    for(; i &lt; count; ++i) {
		        f = err[i] &lt;= t;
		        mask[i] = f;
		        numinliers += f;
		    }
		    return numinliers;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.motion_model.homography2d.prototype.run" id="apidoc.element.jsfeat.motion_model.homography2d.prototype.run">
        function <span class="apidocSignatureSpan">jsfeat.motion_model.homography2d.prototype.</span>run
        <span class="apidocSignatureSpan">(from, to, model, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (from, to, model, count) {
	        	var i=0,j=0;
	        	var md=model.data, t0d=T0.data, t1d=T1.data;
	        	var LtL=mLtL.data, evd=Evec.data;
	        	var x=0.0,y=0.0,X=0.0,Y=0.0;

			    // norm
				var smx=0.0, smy=0.0, cmx=0.0, cmy=0.0, sMx=0.0, sMy=0.0, cMx=0.0, cMy=0.0;

				for(; i &lt; count; ++i) {
				    cmx += to[i].x;
				    cmy += to[i].y;
				    cMx += from[i].x;
				    cMy += from[i].y;
				}

			    cmx /= count; cmy /= count;
			    cMx /= count; cMy /= count;

			    for(i = 0; i &lt; count; ++i)
			    {
				    smx += Math.abs(to[i].x - cmx);
				    smy += Math.abs(to[i].y - cmy);
				    sMx += Math.abs(from[i].x - cMx);
				    sMy += Math.abs(from[i].y - cMy);
				}

			    if( Math.abs(smx) &lt; jsfeat.EPSILON
			    	|| Math.abs(smy) &lt; jsfeat.EPSILON
			    	|| Math.abs(sMx) &lt; jsfeat.EPSILON
			    	|| Math.abs(sMy) &lt; jsfeat.EPSILON ) return 0;

			    smx = count/smx; smy = count/smy;
			    sMx = count/sMx; sMy = count/sMy;

			    t0d[0] = sMx; 	t0d[1] = 0; 	t0d[2] = -cMx*sMx;
			    t0d[3] = 0; 	t0d[4] = sMy; 	t0d[5] = -cMy*sMy;
			    t0d[6] = 0; 	t0d[7] = 0; 	t0d[8] = 1;

				t1d[0] = 1.0/smx; 	t1d[1] = 0; 		t1d[2] = cmx;
				t1d[3] = 0; 		t1d[4] = 1.0/smy; 	t1d[5] = cmy;
				t1d[6] = 0; 		t1d[7] = 0; 		t1d[8] = 1;
				//

				// construct system
				i = 81;
				while(--i &gt;= 0) {
					LtL[i] = 0.0;
				}
				for(i = 0; i &lt; count; ++i) {
					x = (to[i].x - cmx) * smx;
					y = (to[i].y - cmy) * smy;
					X = (from[i].x - cMx) * sMx;
					Y = (from[i].y - cMy) * sMy;

					LtL[0] += X*X;
					LtL[1] += X*Y;
					LtL[2] += X;

					LtL[6] += X*-x*X;
					LtL[7] += X*-x*Y;
					LtL[8] += X*-x;
					LtL[10] += Y*Y;
					LtL[11] += Y;

					LtL[15] += Y*-x*X;
					LtL[16] += Y*-x*Y;
					LtL[17] += Y*-x;
					LtL[20] += 1.0;

					LtL[24] += -x*X;
					LtL[25] += -x*Y;
					LtL[26] += -x;
					LtL[30] += X*X;
					LtL[31] += X*Y;
					LtL[32] += X;
					LtL[33] += X*-y*X;
					LtL[34] += X*-y*Y;
					LtL[35] += X*-y;
					LtL[40] += Y*Y;
					LtL[41] += Y;
					LtL[42] += Y*-y*X;
					LtL[43] += Y*-y*Y;
					LtL[44] += Y*-y;
					LtL[50] += 1.0;
					LtL[51] += -y*X;
					LtL[52] += -y*Y;
					LtL[53] += -y;
					LtL[60] += -x*X*-x*X + -y*X*-y*X;
					LtL[61] += -x*X*-x*Y + -y*X*-y*Y;
					LtL[62] += -x*X*-x + -y*X*-y;
					LtL[70] += -x*Y*-x*Y + -y*Y*-y*Y;
					LtL[71] += -x*Y*-x + -y*Y*-y;
					LtL[80] += -x*-x + -y*-y;
				}
				//

				// symmetry
			    for(i = 0; i &lt; 9; ++i) {
			        for(j = 0; j &lt; i; ++j)
			            LtL[i*9+j] = LtL[j*9+i];
			    }

				jsfeat.linalg.eigenVV(mLtL, Evec);

				md[0]=evd[72], md[1]=evd[73], md[2]=evd[74];
			    md[3]=evd[75], md[4]=evd[76], md[5]=evd[77];
			    md[6]=evd[78], md[7]=evd[79], md[8]=evd[80];

				// denormalize
			    jsfeat.matmath.multiply_3x3(model, T1, model);
			    jsfeat.matmath.multiply_3x3(model, model, T0);

			    // set bottom right to 1.0
			    x = 1.0/md[8];
			    md[0] *= x; md[1] *= x; md[2] *= x;
			    md[3] *= x; md[4] *= x; md[5] *= x;
			    md[6] *= x; md[7] *= x; md[8] = 1.0;

			    return 1;
	        }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			    var inliers_max = -1, numinliers=0;
			    var nmodels = 0;

			    var err = err_buff.f32;

			    // special case
			    if(count == model_points) {
			        if(kernel.<span class="apidocCodeKeywordSpan">run</span>(from, to, M, count) &lt;= 0) {
			        	jsfeat.cache.put_buffer(m_buff);
			        	jsfeat.cache.put_buffer(ms_buff);
			        	jsfeat.cache.put_buffer(err_buff);
			        	return false;
			        }

			        M.copy_to(model);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.optical_flow_lk" id="apidoc.module.jsfeat.optical_flow_lk">module jsfeat.optical_flow_lk</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.optical_flow_lk.track" id="apidoc.element.jsfeat.optical_flow_lk.track">
        function <span class="apidocSignatureSpan">jsfeat.optical_flow_lk.</span>track
        <span class="apidocSignatureSpan">(prev_pyr, curr_pyr, prev_xy, curr_xy, count, win_size, max_iter, status, eps, min_eigen_threshold)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">track = function (prev_pyr, curr_pyr, prev_xy, curr_xy, count, win_size, max_iter, status, eps, min_eigen_threshold) {
    if (typeof max_iter === "undefined") { max_iter = 30; }
    if (typeof status === "undefined") { status = new Uint8Array(count); }
    if (typeof eps === "undefined") { eps = 0.01; }
    if (typeof min_eigen_threshold === "undefined") { min_eigen_threshold = 0.0001; }

    var half_win = (win_size-1)*0.5;
    var win_area = (win_size*win_size)|0;
    var win_area2 = win_area &lt;&lt; 1;
    var prev_imgs = prev_pyr.data, next_imgs = curr_pyr.data;
    var img_prev=prev_imgs[0].data,img_next=next_imgs[0].data;
    var w0 = prev_imgs[0].cols, h0 = prev_imgs[0].rows,lw=0,lh=0;

    var iwin_node = jsfeat.cache.get_buffer(win_area&lt;&lt;2);
    var deriv_iwin_node = jsfeat.cache.get_buffer(win_area2&lt;&lt;2);
    var deriv_lev_node = jsfeat.cache.get_buffer((h0*(w0&lt;&lt;1))&lt;&lt;2);

    var deriv_m = new jsfeat.matrix_t(w0, h0, jsfeat.S32C2_t, deriv_lev_node.data);

    var iwin_buf = iwin_node.i32;
    var deriv_iwin = deriv_iwin_node.i32;
    var deriv_lev = deriv_lev_node.i32;

    var dstep=0,src=0,dsrc=0,iptr=0,diptr=0,jptr=0;
    var lev_sc=0.0,prev_x=0.0,prev_y=0.0,next_x=0.0,next_y=0.0;
    var prev_delta_x=0.0,prev_delta_y=0.0,delta_x=0.0,delta_y=0.0;
    var iprev_x=0,iprev_y=0,inext_x=0,inext_y=0;
    var i=0,j=0,x=0,y=0,level=0,ptid=0,iter=0;
    var brd_tl=0,brd_r=0,brd_b=0;
    var a=0.0,b=0.0,b1=0.0,b2=0.0;

    // fixed point math
    var W_BITS14 = 14;
    var W_BITS4 = 14;
    var W_BITS1m5 = W_BITS4 - 5;
    var W_BITS1m51 = (1 &lt;&lt; ((W_BITS1m5) - 1));
    var W_BITS14_ = (1 &lt;&lt; W_BITS14);
    var W_BITS41 = (1 &lt;&lt; ((W_BITS4) - 1));
    var FLT_SCALE = 1.0/(1 &lt;&lt; 20);
    var iw00=0,iw01=0,iw10=0,iw11=0,ival=0,ixval=0,iyval=0;
    var A11=0.0,A12=0.0,A22=0.0,D=0.0,min_eig=0.0;

    var FLT_EPSILON = 0.00000011920929;
    eps *= eps;

    // reset status
    for(; i &lt; count; ++i) {
        status[i] = 1;
    }

    var max_level = (prev_pyr.levels - 1)|0;
    level = max_level;

    for(; level &gt;= 0; --level) {
        lev_sc = (1.0/(1 &lt;&lt; level));
        lw = w0 &gt;&gt; level;
        lh = h0 &gt;&gt; level;
        dstep = lw &lt;&lt; 1;
        img_prev = prev_imgs[level].data;
        img_next = next_imgs[level].data;

        brd_r = (lw - win_size)|0;
        brd_b = (lh - win_size)|0;

        // calculate level derivatives
        scharr_deriv(prev_imgs[level], deriv_m);

        // iterate through points
        for(ptid = 0; ptid &lt; count; ++ptid) {
            i = ptid &lt;&lt; 1;
            j = i + 1;
            prev_x = prev_xy[i]*lev_sc;
            prev_y = prev_xy[j]*lev_sc;

            if( level == max_level ) {
                next_x = prev_x;
                next_y = prev_y;
            } else {
                next_x = curr_xy[i]*2.0;
                next_y = curr_xy[j]*2.0;
            }
            curr_xy[i] = next_x;
            curr_xy[j] = next_y;

            prev_x -= half_win;
            prev_y -= half_win;
            iprev_x = prev_x|0;
            iprev_y = prev_y|0;

            // border check
            x = (iprev_x &lt;= brd_tl)|(iprev_x &gt;= brd_r)|(iprev_y &lt;= brd_tl)|(iprev_y &gt;= brd_b);
            if( x != 0 ) {
                if( level == 0 ) {
                    status[ptid] = 0;
                }
                continue;
            }

            a = prev_x - iprev_x;
            b = prev_y - iprev_y;
            iw00 = (((1.0 - a)*(1.0 - b)*W_BITS14_) + 0.5)|0;
            iw01 = ((a*(1.0 - b)*W_BITS14_) + 0.5)|0;
            iw10 = (((1.0 - a)*b*W_BITS14_) + 0.5)|0;
            iw11 = (W_BITS14_ - iw00 - iw01 - iw10);

            A11 = 0.0, A12 = 0.0, A22 = 0.0;

            // extract the patch from the first image, compute covariation matrix of derivatives
            for( y = 0; y &lt; win_size; ++y ) {
                src = ( (y + iprev_y)*lw + iprev_x )|0;
                dsrc = src &lt;&lt; 1;

                iptr = (y*win_size)|0;
                diptr = iptr &lt;&lt; 1;
                for(x = 0 ; x &lt; win_size; ++x, ++src, ++iptr, dsrc += 2) {
                    ival = ( (img_prev[src])*iw00 + ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.orb" id="apidoc.module.jsfeat.orb">module jsfeat.orb</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.orb.describe" id="apidoc.element.jsfeat.orb.describe">
        function <span class="apidocSignatureSpan">jsfeat.orb.</span>describe
        <span class="apidocSignatureSpan">(src, corners, count, descriptors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (src, corners, count, descriptors) {
			var DESCR_SIZE = 32; // bytes;
				var i=0,b=0,px=0.0,py=0.0,angle=0.0;
				var t0=0, t1=0, val=0;
				var img = src.data, w = src.cols, h = src.rows;
				var patch_d = patch_img.data;
				var patch_off = 16*32 + 16; // center of patch
				var patt=0;

				if(!(descriptors.type&amp;jsfeat.U8_t)) {
					// relocate to U8 type
					descriptors.type = jsfeat.U8_t;
					descriptors.cols = DESCR_SIZE;
	                descriptors.rows = count;
	                descriptors.channel = 1;
					descriptors.allocate();
				} else {
					descriptors.resize(DESCR_SIZE, count, 1);
				}

				var descr_d = descriptors.data;
				var descr_off = 0;

				for(i = 0; i &lt; count; ++i) {
					px = corners[i].x;
					py = corners[i].y;
					angle = corners[i].angle;

					rectify_patch(src, patch_img, angle, px, py, 32);

					// describe the patch
					patt = 0;
					for (b = 0; b &lt; DESCR_SIZE; ++b) {
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val = (t0 &lt; t1)|0;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 1;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 2;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 3;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 4;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 5;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 6;
			
			            t0 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            t1 = patch_d[patch_off + bit_pattern_31_[patt+1] * 32 + bit_pattern_31_[patt]]; patt += 2
			            val |= (t0 &lt; t1) &lt;&lt; 7;
			
			            descr_d[descr_off+b] = val;
			        }
			        descr_off += DESCR_SIZE;
				}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.pyramid_t" id="apidoc.module.jsfeat.pyramid_t">module jsfeat.pyramid_t</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.pyramid_t.pyramid_t" id="apidoc.element.jsfeat.pyramid_t.pyramid_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>pyramid_t
        <span class="apidocSignatureSpan">(levels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pyramid_t(levels) {
    this.levels = levels|0;
    this.data = new Array(levels);
    this.pyrdown = jsfeat.imgproc.pyrdown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       r2.x &gt;= r1.x - distance &amp;&amp;
       r2.y &lt;= r1.y + distance &amp;&amp;
       r2.y &gt;= r1.y - distance &amp;&amp;
       r2.width &lt;= (r1.width * 1.5 + 0.5)|0 &amp;&amp;
       (r2.width * 1.5 + 0.5)|0 &gt;= r1.width;
        }

        var img_pyr = new jsfeat.<span class="apidocCodeKeywordSpan">pyramid_t</span>(1);

        return {

interval: 4,
scale: 1.1486,
next: 5,
scale_to: 1,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.pyramid_t.prototype" id="apidoc.module.jsfeat.pyramid_t.prototype">module jsfeat.pyramid_t.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.pyramid_t.prototype.allocate" id="apidoc.element.jsfeat.pyramid_t.prototype.allocate">
        function <span class="apidocSignatureSpan">jsfeat.pyramid_t.prototype.</span>allocate
        <span class="apidocSignatureSpan">(start_w, start_h, data_type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocate = function (start_w, start_h, data_type) {
    var i = this.levels;
    while(--i &gt;= 0) {
        this.data[i] = new matrix_t(start_w &gt;&gt; i, start_h &gt;&gt; i, data_type);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// columns, rows, data_type
function matrix_t(c, r, data_type, data_buffer) {
    this.type = get_data_type(data_type)|0;
    this.channel = get_channel(data_type)|0;
    this.cols = c|0;
    this.rows = r|0;
    if (typeof data_buffer === "undefined") {
        this.<span class="apidocCodeKeywordSpan">allocate</span>();
    } else {
        this.buffer = data_buffer;
        // data user asked for
        this.data = this.type&amp;U8_t ? this.buffer.u8 : (this.type&amp;S32_t ? this.buffer.i32 : (this.type&amp;F32_t ? this
.buffer.f32 : this.buffer.f64));
    }
}
matrix_t.prototype.allocate = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.pyramid_t.prototype.build" id="apidoc.element.jsfeat.pyramid_t.prototype.build">
        function <span class="apidocSignatureSpan">jsfeat.pyramid_t.prototype.</span>build
        <span class="apidocSignatureSpan">(input, skip_first_level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (input, skip_first_level) {
    if (typeof skip_first_level === "undefined") { skip_first_level = true; }
    // just copy data to first level
    var i = 2, a = input, b = this.data[0];
    if(!skip_first_level) {
        var j=input.cols*input.rows;
        while(--j &gt;= 0) {
            b.data[j] = input.data[j];
        }
    }
    b = this.data[1];
    this.pyrdown(a, b);
    for(; i &lt; this.levels; ++i) {
        a = b;
        b = this.data[i];
        this.pyrdown(a, b);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.ransac_params_t" id="apidoc.module.jsfeat.ransac_params_t">module jsfeat.ransac_params_t</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.ransac_params_t.ransac_params_t" id="apidoc.element.jsfeat.ransac_params_t.ransac_params_t">
        function <span class="apidocSignatureSpan">jsfeat.</span>ransac_params_t
        <span class="apidocSignatureSpan">(size, thresh, eps, prob)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ransac_params_t(size, thresh, eps, prob) {
    if (typeof size === "undefined") { size=0; }
    if (typeof thresh === "undefined") { thresh=0.5; }
    if (typeof eps === "undefined") { eps=0.5; }
    if (typeof prob === "undefined") { prob=0.99; }

    this.size = size;
    this.thresh = thresh;
    this.eps = eps;
    this.prob = prob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.ransac_params_t.prototype" id="apidoc.module.jsfeat.ransac_params_t.prototype">module jsfeat.ransac_params_t.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.ransac_params_t.prototype.update_iters" id="apidoc.element.jsfeat.ransac_params_t.prototype.update_iters">
        function <span class="apidocSignatureSpan">jsfeat.ransac_params_t.prototype.</span>update_iters
        <span class="apidocSignatureSpan">(_eps, max_iters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update_iters = function (_eps, max_iters) {
	        var num = Math.log(1 - this.prob);
	        var denom = Math.log(1 - Math.pow(1 - _eps, this.size));
	        return (denom &gt;= 0 || -num &gt;= max_iters*(-denom) ? max_iters : Math.round(num/denom))|0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			        numinliers = find_inliers(kernel, M, from, to, count, params.thresh, err, curr_mask.data);

			        if( numinliers &gt; Math.max(inliers_max, model_points-1) ) {
			            M.copy_to(model);
			            inliers_max = numinliers;
			            if(mask) curr_mask.copy_to(mask);
			            niters = params.<span class="apidocCodeKeywordSpan">update_iters</span>((count - numinliers)/count, niters);
			            result = true;
			        }
			    }

			    jsfeat.cache.put_buffer(m_buff);
			    jsfeat.cache.put_buffer(ms_buff);
			    jsfeat.cache.put_buffer(err_buff);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.yape" id="apidoc.module.jsfeat.yape">module jsfeat.yape</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.yape.detect" id="apidoc.element.jsfeat.yape.detect">
        function <span class="apidocSignatureSpan">jsfeat.yape.</span>detect
        <span class="apidocSignatureSpan">(src, points, border)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (src, points, border) {
    if (typeof border === "undefined") { border = 4; }
    var t = this.level_tables[0];
    var R = t.radius|0, Rm1 = (R-1)|0;
    var dirs = t.dirs;
    var dirs_count = t.dirs_count|0;
    var opposite = dirs_count &gt;&gt; 1;
    var img = src.data, w=src.cols|0, h=src.rows|0,hw=w&gt;&gt;1;
    var scores = t.scores;
    var x=0,y=0,row=0,rowx=0,ip=0,im=0,abs_score=0, score=0;
    var tau = this.tau|0;
    var number_of_points = 0, pt;

    var sx = Math.max(R+1, border)|0;
    var sy = Math.max(R+1, border)|0;
    var ex = Math.min(w-R-2, w-border)|0;
    var ey = Math.min(h-R-2, h-border)|0;

    row = (sy*w+sx)|0;
    for(y = sy; y &lt; ey; ++y, row+=w) {
        for(x = sx, rowx = row; x &lt; ex; ++x, ++rowx) {
            ip = img[rowx] + tau, im = img[rowx] - tau;

            if (im&lt;img[rowx+R] &amp;&amp; img[rowx+R]&lt;ip &amp;&amp; im&lt;img[rowx-R] &amp;&amp; img[rowx-R]&lt;ip) {
                scores[rowx] = 0;
            } else {
                perform_one_point(img, rowx, scores, im, ip, dirs, opposite, dirs_count);
            }
        }
    }

    // local maxima
    row = (sy*w+sx)|0;
    for(y = sy; y &lt; ey; ++y, row+=w) {
        for(x = sx, rowx = row; x &lt; ex; ++x, ++rowx) {
            score = scores[rowx];
            abs_score = Math.abs(score);
            if(abs_score &lt; 5) {
                // if this pixel is 0, the next one will not be good enough. Skip it.
                ++x, ++rowx;
            } else {
                if(third_check(scores, rowx, w) &gt;= 3 &amp;&amp; is_local_maxima(scores, rowx, score, hw, R)) {
                    pt = points[number_of_points];
                    pt.x = x, pt.y = y, pt.score = abs_score;
                    ++number_of_points;

                    x += Rm1, rowx += Rm1;
                }
            }
        }
    }

    return number_of_points;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsfeat.yape.init" id="apidoc.element.jsfeat.yape.init">
        function <span class="apidocSignatureSpan">jsfeat.yape.</span>init
        <span class="apidocSignatureSpan">(width, height, radius, pyramid_levels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (width, height, radius, pyramid_levels) {
    if (typeof pyramid_levels === "undefined") { pyramid_levels = 1; }
    var i;
    radius = Math.min(radius, 7);
    radius = Math.max(radius, 3);
    for(i = 0; i &lt; pyramid_levels; ++i) {
        this.level_tables[i] = new lev_table_t(width&gt;&gt;i, height&gt;&gt;i, radius);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsfeat.yape06" id="apidoc.module.jsfeat.yape06">module jsfeat.yape06</a></h1>


    <h2>
        <a href="#apidoc.element.jsfeat.yape06.detect" id="apidoc.element.jsfeat.yape06.detect">
        function <span class="apidocSignatureSpan">jsfeat.yape06.</span>detect
        <span class="apidocSignatureSpan">(src, points, border)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (src, points, border) {
    if (typeof border === "undefined") { border = 5; }
    var x=0,y=0;
    var w=src.cols, h=src.rows, srd_d=src.data;
    var Dxx = 5, Dyy = (5 * w)|0;
    var Dxy = (3 + 3 * w)|0, Dyx = (3 - 3 * w)|0;
    var lap_buf = jsfeat.cache.get_buffer((w*h)&lt;&lt;2);
    var laplacian = lap_buf.i32;
    var lv=0, row=0,rowx=0,min_eigen_value=0,pt;
    var number_of_points = 0;
    var lap_thresh = this.laplacian_threshold;
    var eigen_thresh = this.min_eigen_value_threshold;

    var sx = Math.max(5, border)|0;
    var sy = Math.max(3, border)|0;
    var ex = Math.min(w-5, w-border)|0;
    var ey = Math.min(h-3, h-border)|0;

    x = w*h;
    while(--x&gt;=0) {laplacian[x]=0;}
    compute_laplacian(srd_d, laplacian, w, h, Dxx, Dyy, sx,sy, ex,ey);

    row = (sy*w+sx)|0;
    for(y = sy; y &lt; ey; ++y, row += w) {
        for(x = sx, rowx=row; x &lt; ex; ++x, ++rowx) {

            lv = laplacian[rowx];
            if ((lv &lt; -lap_thresh &amp;&amp;
                lv &lt; laplacian[rowx - 1]      &amp;&amp; lv &lt; laplacian[rowx + 1] &amp;&amp;
                lv &lt; laplacian[rowx - w]     &amp;&amp; lv &lt; laplacian[rowx + w] &amp;&amp;
                lv &lt; laplacian[rowx - w - 1] &amp;&amp; lv &lt; laplacian[rowx + w - 1] &amp;&amp;
                lv &lt; laplacian[rowx - w + 1] &amp;&amp; lv &lt; laplacian[rowx + w + 1])
                ||
                (lv &gt; lap_thresh &amp;&amp;
                lv &gt; laplacian[rowx - 1]      &amp;&amp; lv &gt; laplacian[rowx + 1] &amp;&amp;
                lv &gt; laplacian[rowx - w]     &amp;&amp; lv &gt; laplacian[rowx + w] &amp;&amp;
                lv &gt; laplacian[rowx - w - 1] &amp;&amp; lv &gt; laplacian[rowx + w - 1] &amp;&amp;
                lv &gt; laplacian[rowx - w + 1] &amp;&amp; lv &gt; laplacian[rowx + w + 1])
                ) {

                min_eigen_value = hessian_min_eigen_value(srd_d, rowx, lv, Dxx, Dyy, Dxy, Dyx);
                if (min_eigen_value &gt; eigen_thresh) {
                    pt = points[number_of_points];
                    pt.x = x, pt.y = y, pt.score = min_eigen_value;
                    ++number_of_points;
                    ++x, ++rowx; // skip next pixel since this is maxima in 3x3
                }
            }
        }
    }

    jsfeat.cache.put_buffer(lap_buf);

    return number_of_points;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>